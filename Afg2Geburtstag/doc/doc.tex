\documentclass{article}

\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=2.2cm,footskip=0.5cm]{geometry}

\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ntheorem}

\usepackage{lmodern}
%\usepackage{csquotes}

\usepackage{tikz}
\usetikzlibrary{chains}
\usetikzlibrary{matrix,positioning,calc}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{breqn}
\usepackage{tabularx}
\usepackage{longtable}

\usepackage{cite}

\usepackage{fancyhdr, lastpage}

\pagestyle{fancy}

\newcommand{\Fpage}{\thepage{}/\pageref{LastPage}}
\newcommand{\Ftitle}{Aufgabe 2 Geburtstag}
\newcommand{\Fauthor}{Nikolas Kilian}

\lhead{\Fauthor}
\rhead{\Ftitle}
\chead{}
\lfoot{}
\rfoot{}
\cfoot{\Fpage}

\setlength{\parskip}{.8em} 
\setlength{\parindent}{0pt}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}
%\usepackage{pxfonts}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

%
% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

\usepackage{url}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\normalfont}
\theoremseparator{.\,—}
\theoremsymbol{}
\newtheorem{proof-wo}{Beweis}
\theoremsymbol{\ensuremath{\color{lightgray}\blacksquare}}
\newtheorem{proof}{Beweis}


%\usepackage{courier}
%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{turqoisetypes}{rgb}{0.01,0.60,0.3}
\definecolor{background}{rgb}{0.95,0.95,0.95}
%\definecolor{background}{rgb}{.97,.97,.97}

\newcommand{\codesize}{\small}

\lstdefinelanguage{CSharp}{ % Better C# highlighting
language=[Sharp]C,
frame=lrbt,
%language=general,
backgroundcolor=\color{background},
captionpos=b,
numbers=left,
numberstyle=\tiny,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, get, set, from, select, package, deref},
%
emph=[0]{T,U,V,TToken},
emphstyle=[0]{\color{types}},
%
emph=[1]{BigRational,BigInteger,NotSupportedException,List,HashSet,ITerm,BinaryOperation,UnaryOperation,BinaryOperator,UnaryOperator,DigitFarm},
emphstyle=[1]{\color{turqoisetypes}},
%
otherkeywords={=>,<,>},
emph=[2]{=>,<,>},
emphstyle=[2]{\bfseries},
%
emph=[3]{ParserResult},
emph=[3]{\color{turqoisetypes}\bfseries},
%
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\codesize\ttfamily,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

\lstMakeShortInline[
  language=CSharp,
  columns=fixed,]~

  \lstnewenvironment{lstcs}[1][]
  {\lstset{
      language=CSharp,
      breaklines=true,
      columns=fullflexible,
      caption={#1}
  }}
{}

\newcommand{\sidenote}[1]{&&\left|\ \text{#1}\right.}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\delimitershortfall=-1pt

\let\svlp(
\catcode`(=\active %
\def(#1){\left\svlp#1\right)}
\catcode`(=12 %
\newcommand\pactive{\catcode`(=\active }
\everymath{\pactive}
\everydisplay{\pactive}

\usepackage{hyperref}
\usepackage{cleveref}

\begin{document}

%\textcolor{red}{Ich habe mal Deine Funktion von $\varphi_{d,b}$ auf $\Phi_d$ geändert und das $b$ darin weggelassen, dessen Bedeutung sich mir an dieser Stelle noch nicht erschließt. Kuck mal, ob Dir das so gefällt. Ich finde es besser. Wenn nicht: Ich habe Deine alte Definition auskommentiert, dann einfach meine wieder löschen. Wenn das $b$ wichtig ist, könntest Du vielleicht auch $\Phi_d^b$ nehmen, das finde ich noch besser leserlich als $\varphi_{d,b}$.}

\section{Lösungsidee}

Die Kernidee des Algorithmus besteht darin, alle jene Terme zu ermitteln, die mit \(n\) Ziffern optimal ihren Wert darstellen.
Dies wird induktiv gelöst, wobei für die Errechnung der optimalen Terme mit Größe \(n\) alle kleineren Terme vorausgesetzt werden.
Zuerst werden alle infrage kommenden Terme mit Größe \(n\) gebildet. Hierzu werden alle Terme der Größe \(i\) mit allen Termen der Größe \(n-i\) unter Verwendung aller binärer Operationen gekreuzt.
Daraufhin werden alle Terme entfernt, deren Wert schon mit kleineren oder gleich großen Termen dargestellt wurde.
Um mit diesem Verfahren nun die Aufgabe zu lösen, ermittelt man solange größere Terme, bis der gesuchte Wert optimal von einem Term dargestellt wird.
Diese Vorangehensweise erlaubt es auch, mit der gleichen Ziffer Repräsentationen für mehrere Zahlen auf einmal zu finden, ohne dass sich die Laufzeit addiert.
Hierfür werden einfach größere und größere Terme ermittelt, bis alle Zahlen eine optimale Repräsentation erhalten haben.
Die Laufzeit entspricht hierbei einfach der längsten Laufzeit der individuellen Zahlen.

Auf ersten Blick scheint dieser Algorithmus eine stark explosive Komplexität zu besitzen, tatsächlich ist dem aber gar nicht so.
Im folgenden wird die Komplexität dieses Verfahrens genauer betrachtet.

\newcommand{\fad}{\forall d, b:\ }
%\newcommand{\measure}[1]{\varphi_{d,b}\left(#1\right)}
\newcommand{\measure}[1]{\Phi_{d}^{B}\left(#1\right)}

\subsection{Größenmaß-Funktion}

Zur Berechnung der Komplexität wird die Größenmaß-Funktion \(\Phi_{d}^{B} : \mathbb{Q} \to \mathbb{N}\) betrachtet, die die Anzahl an Instanzen der Ziffer \(d\) errechnet, die für die optimale Repräsentation beliebiger rationaler Zahlen benötigt wird, wobei Konkatenierung (also z.B. \(11\) aus zwei mal der Ziffer \(1\) generieren) in Basis \(B\) stattfindet. Beispielsweise ist \(\fad\measure{d} = 1\).

%\textcolor{red}{\em Anstelle von 'Verwendungen der Ziffer' vielleicht 'Instanzen der Ziffer'? Für was steht denn das 'b' in der Funktion? Könntest Du das 'b' in der Definition der Funktion auch weglassen? Würde die Sache übersichtlicher machen ... Bis zu dieser Stelle wird es mir jedenfalls nicht klar, was 'b' überhaupt ist. Geht das aus der Aufgabenstellung hervor? Aber selbst wenn dem so ist, dann solltest Du das 'b' in dem Text oben drüber nochmal irgendwie erwähnen, ansonsten fällt das hier vom Himmel.}

\begin{lemma}[Größenmaß für nicht-negative ganze Zahlen]\label{lemma:measure_linear_nonnegative}
    Für jede nicht-negative ganze Zahl \(n\) gilt:

    \[\measure{n} \leq n + 2\]
\end{lemma}
\begin{proof}
    \subsubsection*{Fall 1: \(n > 0\)}
    
    \(n > 0\) lässt sich als \(n\) mal wiederholte Summierung von \(d\) darstellen:
    \[n = \frac{d+d+\ldots+d}{d} \implies \measure{n} \leq n + 1 < n + 2\]

    \subsubsection*{Fall 2: \(n = 0\)}
        
    \(n = 0\) lässt sich immer mit genau zwei Ziffern darstellen:
    \[n = d - d \implies \measure{n} \leq 2 = n + 2\]
\end{proof}
\begin{corollary}[Größenmaß für ganze Zahlen]\label{lemma:measure_linear}
    Für jede ganze Zahl \(n\) gilt:

    \[\fad \measure{n} \leq |n| + 3\]
\end{corollary}

\begin{proof}
    \subsubsection*{Fall 1: \(n \geq 0\)}

    Laut \ref{lemma:measure_linear_nonnegative} gilt:
    \[\measure{n} \leq n + 2 = |n| + 2 < |n| + 3\]

    \subsubsection*{Fall 2: \(n < 0\)}
        
    \(n < 0\) lässt sich als Differenz aus \(0 = d-d\) und \(d\) darstellen:
    \[n = d - d - \frac{d+d+\ldots+d}{d} \implies \measure{n} \leq |n| + 3\]
    oder alternativ unter Verwendung von unärer Negation:
    \[n = -\frac{d+d+\ldots+d}{d} \implies \measure{n} \leq |n| + 1 < |n| + 3\]
\end{proof}

\begin{lemma}[Größenmaß für binäre Operationen]\label{lemma:phi_binary}
    Für jede binäre Operation \(\circ : \mathbb{Q} \times \mathbb{Q} \to \mathbb{Q}\) gilt für alle \(a\in\mathbb{Q},\ b\in\mathbb{Q}\):

    \[\measure{a \circ b} \leq \measure{a} + \measure{b}\]

    Es werden quasi alle binären Operatoren in Addition umgewandelt.
\end{lemma}
\begin{proof}
    Die natürlichen Zahlen \(a\) und \(b\) lassen sich mit \(\measure{a}\) bzw. \(\measure{b}\) Ziffern ausdrücken, also lässt sich \(a \circ b\) durch Anwendung der Operation \(\circ\) auf die Terme für \(a\) und \(b\) mit \(\measure{a} + \measure{b}\) oder weniger Ziffern ausdrücken.
\end{proof}

\begin{corollary}[Größenmaß für rationale Zahlen]\label{corollary:phi_rational}
    Für jede rationale Zahl \(\frac{a}{b}\in\mathbb{Q},\ a\in\mathbb{Z},\ b\in\mathbb{Z}^+\) gilt:

    \[\measure{\frac{a}{b}} \leq \measure{a} + \measure{b}\]
\end{corollary}
\begin{proof}
    \(\frac{a}{b}\) ist das Ergebnis der Anwendung des binären Divisions-Operators auf \(a\) und \(b\), somit lässt es sich laut \ref{lemma:phi_binary} mit \(\measure{a} + \measure{b}\) oder weniger Ziffern ausdrücken.
\end{proof}
%\textcolor{red}{Das ist doch hier ein anderes 'b' als das in Deiner ursprünglichen Definition von $\varphi_{d,b}$? Ich finde, Du solltest Dein 'b' unbedingt noch erläutern.}
\begin{theorem}[Genauere obere Grenze des Größenmaßes für positive ganze Zahlen]\label{theorem:accurate_bound}
    Für jede positive ganze Zahl \(n\) gilt:
    
        \[\measure{n} \leq \log_d(n) \cdot (d+4)\]
\end{theorem}
\begin{proof}
    Jede positive ganze Zahl lässt sich im Horner-Schema darstellen.
    Betrachte man die natürliche Zahl \(n\) in Basis \(d\).

        \begin{equation}\label{eqn:horner_schema}
            n = a_1 + d (a_2 + d (\ldots d a_k)),\ a_i\in\mathbb{N},\ 0 \leq a_i < d
        \end{equation}

    Hierbei ist es anzumerken, dass keine Basis 1 existiert und dies somit bei \(d=1\) nicht anwendbar ist.
    Im folgenden wird zuerst der generelle Fall betrachtet.
    Aus \ref{eqn:horner_schema} lässt sich ablesen:

    \begin{align*}
        \measure{n} 
        &\leq \measure{a_1 + d (a_2 + d (\ldots d a_k))} \sidenote{\ref{lemma:phi_binary}} \\
        &\leq \measure{a_1} + \measure{d} + \measure{a_2} + \measure{d} + \ldots + \measure{d} + \measure{a_k} \\
        &= (k-1)\cdot\measure{d} + \sum_{i=1}^k \measure{a_i} \numberthis\label{eqn:semi_accurate_bound}
    \end{align*}
    
    Da \(0 \leq a_i < d\) gilt, folgt mit \ref{lemma:measure_linear_nonnegative} für jedes \(a_i\): \(\measure{a_i} \leq d + 2\).
    Zusammen mit \(\measure{d} = 1\) folgt aus \ref{eqn:semi_accurate_bound}:
    
%\textcolor{red}{Bei der nachfolgenden Auflistung würde ich die erste Zeile weglassen, denn diese ist nur eine Dopplung Deiner Gleichung (2) obendrüber, fange gleich mit der nächsten Ungleichung an}
    \begin{align*}
        \measure{n} 
        &\leq (k-1) \cdot 1 + \sum_{i=1}^k (d+2) \\
        &\leq (k-1) + k \cdot (d+2) \\
        &\leq k + k \cdot (d+2) = k \cdot (d+3) \\
    \end{align*}
    
    Bei der Repräsentation mit dem Horner-Schema gilt \(k = \lfloor \log_d(n) \rfloor\), somit folgt:

        \[\measure{n} \leq k \cdot (d+3) = \lfloor \log_d(n) \rfloor \cdot (d+3) \leq \log_d(n) \cdot (d+3)\]

%\textcolor{red}{Warum hier nochmal der Wechsel von $d+3$ zu $d+4$. Das erschließt sich an dieser Stelle für mich nicht.}

    Betrachtet man nun noch einmal den Spezialfall \(d = 1\):
    Um das Problem der non-existenten Basis zu umgehen, kann anstatt \(d = 1\) die Basis \(2 = 1 + 1 = d + d\) betrachtet werden.
     
    %\textcolor{red}{Auch hier würde ich Gleichung (2) nicht nochmal hinschreiben. Vielleicht machst Du das hier so (Deine alte Version ist auskommentiert):} 
    
%    Betrachtet man nun \ref{eqn:semi_accurate_bound}:

%    \[\measure{n} \leq (k-1) \cdot \measure{d} + \sum_{i=1}^k \measure{a_i}\]

 %   Um diese Umgehung des Problems zu integrieren, muss nur \(\measure{d}\) mit \(\measure{d + d} = 2\cdot\measure{d}\) ersetzt werden:

Ausgehend von Gleichung \ref{eqn:semi_accurate_bound}, kann für eine alternative Herleitung \(\measure{d}\) einfach durch 
\(\measure{d + d} = 2\cdot\measure{d}\) ersetzt werden. Es ergibt sich

    \[\measure{n} \leq (k-1) \cdot 2 \cdot \measure{d} + \sum_{i=1}^k \measure{a_i}\]

    Somit folgt analog zu oben:

    \begin{align*}
        \measure{n} 
        &\leq k \cdot (d+4) \\
        &\leq \log_d(n) \cdot (d+4) \\
    \end{align*}

    %\textcolor{red}{Auch hier nochmal: Wozu brauchst Du die 4?}

    Somit gilt sowohl im generellen Fall als auch im Spezialfall die Abschätzung \(\measure{n} \leq \log_d(n) \cdot (d+4)\).
\end{proof}

\begin{corollary}[Genauere obere Grenze des Größenmaßes für ganze Zahlen]\label{corollary:phi_bound}
    Für jede ganze Zahl \(n\) gilt:
    
        \[\measure{n} \leq \log_d(n) \cdot (d+4) + 2\]
\end{corollary}
\begin{proof}
    Analog zum Beweis von \ref{lemma:measure_linear}.
\end{proof}

\subsection{Anzahl an Termen}

Die Anzahl an Termen mit \(n\) Ziffern sei definiert als \(t_n\).
Bei Größe \(0\) gibt es beispielsweise \(t_0 = 0\) Terme, bei \(1\) gibt es \(t_1 = 1\) Terme und bei \(2\) gibt es \(t_2 = 6\) Terme (\(d; dd; d+d; d-d; d \cdot d; d \div d\)).

\begin{theorem}[Abschätzung für \(t_n\)]\label{theorem:tn_bound}
    Die Anzahl an Termen lässt sich wie folgt nach oben abschätzen

        \[t_n \leq C_n \cdot 5^{n-1}\,,\]
     wobei \(C_n\) die Catalan Zahlen bezeichnet.
\end{theorem}
\begin{proof}
    Terme von Größe \(n\) können als volle Binärbäume mit \(n\) Blättern aufgefasst werden, wobei jedes Blatt eine Ziffer oder eine Wiederholung der Ziffer darstellt und jeder Knoten eine binäre Operation zwischen seinen zwei Kindern darstellt.
    Am Beispiel für \(6 = (1+1)\cdot(1+(1+1))\):
    \begin{center}
        \begin{tikzpicture}[level/.style={sibling distance = 4cm/#1,  level distance = 0.8cm}] 
        \node [circle,draw] {$\cdot$}
            child{ node  [circle,draw] {$+$}
                child{ node  [circle,draw] {$1$}} 
                child{ node  [circle,draw] {$1$}} 
            }
            child{ node  [circle,draw] {$+$} 
                child{ node  [circle,draw] {$1$}} 
                child{ node  [circle,draw] {$+$}
                    child{ node  [circle,draw] {$1$}} 
                    child{ node  [circle,draw] {$1$}} 
                } 
            }
        ; 
        \end{tikzpicture}
    \end{center}
    Hierbei werden auch invalide Terme mit Division durch Null wie \(1 \div (1-1)\) mit betrachtet, jedoch sind alle validen Terme wie oben repräsentierbar, somit ist das folgende \textcolor{red}{Was ist denn an dieser Stelle das 'folgende'?} eine obere Abschätzung.
    Nachfolgend werden zunächst nur Terme ohne Konkatenierung von Ziffern betrachtet.

    Betrachte man nun zuerst die Anzahl solcher Binärbäume.
    Die Anzahl an vollen Binärbäumen mit \(n\) Blättern wird durch die Catalan Zahlen \(C_n\) beschrieben.
    Die Catalan Zahlen beschreiben jedoch nur die Anzahl an Binärbäumen, nicht die Anzahl an Binärbäumen mit Operatoren in den Knoten.
    In einem vollen Binärbaum mit \(n\) Blättern gibt es \(n-1\) Knoten bzw. \(n-1\) Operatoren.
    Bei \(4\) Operatoren heißt das, dass die Anzahl an Kombinationen von Operatoren \(4^{n-1}\) beträgt.
    Folglich ist die Anzahl an Binärbäumen mit Operatoren in den Knoten das Produkt dieser beiden Zahlen: \(C_n \cdot 4^{n-1}\).

%\textcolor{red}{Okay, hier taucht zum ersten mal der Index 'b' auf. Es handelt sich also um eine Basis. Aber welche?}
    Um nun noch Konkatenierung von Ziffern mitzubetrachten kann man sich einen Konkatenierungs-Operator vorstellen:
    \[l \circ r = B \cdot l + r \quad\quad 1\circ1 = B + 1 = 10 + 1 = 11\]
    Dieser würde natürlich auch ``unerlaubte'' Konkatenierungen erlauben:
    \[(4+4+4) \circ (4\cdot4) = 12 \circ 16 = 12B + 16 = 120 + 16 = 136\]
    Jedoch werden so alle validen Konkatenierungen und mehr abgebildet, weshalb er für eine Abschätzung nach oben geeignet ist.
    Nun lässt sich die vorherige Herangehensweise analog durchführen, jedoch diesmal mit \(5\) Operatoren.
    Somit ist die Anzahl an Termen der Größe \(n\) kleiner gleich \(C_n \cdot 5^{n-1}\).
\end{proof}

\begin{theorem}[Anzahl zu betrachtender Terme]\label{theorem:tn_of_phi}
    Aus \ref{corollary:phi_bound}, \ref{corollary:phi_rational} und \ref{theorem:tn_bound} folgt, dass für jede rationale Zahl \(n\in\mathbb{Q}\) gilt:

        \[t_{\measure{n}} = \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}\]

    Was bedeuten mag, dass die Anzahl an Termen, die die Ziffer so oft verwenden wie minimal notwendig ist um \(n\) darzustellen, respektiv zu \(n\) polynomial abschätzbar ist.
\end{theorem}

%\stop

%\textcolor{red}{Ich habe in der Darstellung '$\in$' durch '$=$' ersetzt}
\begin{proof}
    Laut \ref{theorem:tn_bound} gilt:

        \[t_n \leq C_n \cdot 5^{n-1}\]

    Für die Catalan Zahlen gilt folgende obere Abschätzung\footnote{Siehe Seite 212: https://www.sciencedirect.com/science/article/pii/S0195669886800245}:

        \[C_n < \frac{4^n}{(n+1)\sqrt{\pi n}}\]

    %\textcolor{red}{Hier musst Du unbedingt noch eine Referenz einfügen, woher Du das hast ... Also einen Literaturverweis. Sonst fällt auch das vom Himmel}
    
    Somit folgt:

        \[t_n \leq C_n \cdot 5^{n-1} < \frac{4^n}{(n+1)\sqrt{\pi n}} 5^{n-1} = \frac{4^n \cdot 5^n}{5(n+1)\sqrt{\pi n}} = \frac{20^n}{5(n+1)\sqrt{\pi n}}\]

    Nun kann man \(\measure{n}\) für \(n\) einsetzen.
    Mit Corollarry \ref{corollary:phi_bound} gilt nach einer ganzen Reihe von Umformungen (siehe Anhang):%(\(\measure{n} \leq \log_d(n)\cdot(d+3)+2\)) gilt:

%    \begin{align*}
%        t_{\measure{\frac{a}{b}}}
 %       &\in \mathcal{O}\left(n^{\frac{d+4}{\log_{20}(d)}} \cdot \underbrace{\big(\log_d(n) \cdot d\big)^{-\frac{3}{2}}}_{\text{streng monoton fallend}}\right) \\
%        &= \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}
 %   \end{align*}
    
    \begin{equation}
        t_{\measure{n}}
        = \mathcal{O}\left(n^{\frac{d+4}{\log_{20}(d)}} \cdot \underbrace{\big(\log_d(n) \cdot d\big)^{-\frac{3}{2}}}_{\text{streng monoton fallend}}\right) \\
        = \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}
    \end{equation}
%\textcolor{red}{Schau Dir das mal so an (in einer Zeile), ich finde das besser ... Auch hier ist wieder $\in$ durch $=$ ersetzt.}

    Da die Ziffer \(d\) dabei immer konstant ist, ist auch \(\alpha\) konstant.
    Somit ist \(t_{\measure{n}}\) nach oben polynomial abschätzbar.
\end{proof}

Da immer alle Ziffern (außer 0) verwendet werden, muss diese Komplexität für alle Ziffern addiert werden.
Somit ist die Komplexität eine Summe aus Potenzen, also ebenfalls eine Potenz:

\[t_{\measure{n}} \in \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\max_{0 < d \leq 9}\frac{d+4}{\log_{20}(d)}\]

%All das mag heißen, dass auch wenn quasi purer Brute-Force verwendet wird, die Komplexität polynomial ist und somit auch die Komplexität des obigen Algorithmus.
Auch wenn quasi purer Brute-Force verwendet wird, so belegen diese Überlegungen dennoch, dass eine polynomiale Komplexität vorliegt.
Da der eigentliche Algorithmus durch die Eliminierung von Duplikaten noch einmal stärker optimiert ist, ist dessen Komplexität natürlich auch polynomial.

\subsection{Exponenten und Fakultäten}

Um den Algorithmus auf Exponenten und Fakultäten zu erweitern, kann zuerst Exponentiation als weiterer binärer Operator wie Addition und Multiplikation hinzugefügt werden, wobei die Komplexität analog zu vorher polynomial bleibt, nur mit einem größeren Exponenten.
Für die Integration von Fakultäten ist dies jedoch nicht so leicht.
Ersteinmal lässt sich Fakultät relativ leicht in den Algorithmus einklinken, wobei jeder neue optimale Term noch einmal mit einer Fakultät hinten zu der Liste aller optimalen Terme addiert wird.
Das Problem hierbei ist, dass Fakultät eine unäre Operation ist, weshalb sie unabhängig von der Anzahl an Instanzen der Ziffer beliebig oft verwendbar ist; beispielsweise ist \(((((d!)!)!)!)!\) in der Theorie erlaubt.
Betrachtet man jedoch die Werte der Fakultäts-Funktion, so fällt auf, dass dort sehr schnell immens große Werte entstehen; beispielsweise ist \((5!)!=120!\), was eine Zahl mit 199 Ziffern ist.
Dass diese Werte nur sehr selten brauchbar sind ist relativ offensichtlich.
Deshalb habe ich zur Umgehung des Problems ganz einfach ein Limit eingefügt, was Fakultäten von Zahlen größer der arbiträr gewählten Grenze \(80\) verbietet.
Somit wird \((4!)!\) gerade noch so erlaubt, jedoch \((5!)!\) verboten.
Dies lässt sich auch leicht implementieren, wobei jeder neue Term mit Wert \(x < 80\) den neuen Term \(x!\) rekursiv einfügt.
Hierbei muss man jedoch noch darauf Achten, dass keine Endlosschleifen auftauchen: \(1 = 1! = \ldots = ((1!)!)!\)

Es lässt sich erkennen, dass hierbei höchstens zwei Fakultäten in Reihe auftreten können.
Das bedeutet, dass für jeden neu gefundenen optimalen Term noch (höchstens) zwei weitere Terme addiert werden, was heißen mag, dass sich die Rechenzeit (höchstens) verdreifacht, und somit immernoch polynomial ist.

Was an Exponenten und Fakultäten hierbei noch interessant ist, ist, dass die Ziffer \(0\) nun auch verwendet werden kann:
\(0^0 = 0! = 1\).
Die Beispiele unten enthalten somit auch Lösungen mit der Ziffer \(0\).

\section{Umsetzung}

Der Algorithmus wurde in C\# 8.0 mit .NET Core 3.1 implementiert.
Der Code ist in zwei Projekte geteilt;
~Afg2Geburtstag.CLI~ und ~Afg2Geburtstag~.
~Afg2Geburtstag.CLI~ kümmert sich um das Konsolen-Interface und ruft ~Afg2Geburtstag~ auf, was den eigentlichen Algorithmus enthält.
~Afg2Geburtstag~ definiert einige Typen:

\begin{description}
    \item[BigRational] definiert mithilfe des BCL-Typs ~BigInteger~ einen Typen für (theoretisch) unendlich große rationale Zahlen.
    \item[ITerm] repräsentiert eine Schnittstelle für beliebige Terme mit einem ~BigRational~ Wert. Wird von ~BigRational~ implementiert.
    \item[UnaryOperation] repräsentiert eine unäre Operation auf einem ~ITerm~ und implementiert selbst ~ITerm~.
    \item[BinaryOperation] repräsentiert eine binäre Operation zwischen zwei ~ITerm~s und implementiert selbst ~ITerm~.
    %\textcolor{red}{Ist das so gedacht mit dem schwarzen 's' hinter dem grünen ITerm?} %Yes
    \item[DigitFarm] enthält den Kernalgorithmus.
\end{description}

~UnaryOperation~ und ~BinaryOperation~ speichern als Optimierung ihren berechneten Wert und Hashcode.
Weiterhin sind die Operanden der beiden Typen ~ITerm~ Instanzen und somit Referenztypen, was bedeutet, dass jede Operation nur einmal gespeichert wird und nicht in anderen Operationen, die sie verwenden, gedoppelt wird.

In ~DigitFarm~, worin der Hauptalgorithmus implementiert wird, werden an vielen Stellen Hashsets verwendet, um schnelle Lookups zu erlauben.
Spezifischer, da ~HashSet<T>~ nicht Thread-Safe ist, verwendet der Code ~ConcurrentDictionary<T, byte>~, wobei der ~byte~-Wert ignoriert wird.

\section{Beispiele}

\paragraph*{~--targets 2020, 2030, 2080, 2980 --digits 0,1,2,3,4,5,6,7,8,9 --exponentiation --factorial --latex~}
\begin{center}
    \begin{longtable}{ | l | l | p{8cm} | l | l | }
    \hline Digit & Value & Term & Digit Usages & Time \\\hline
            4 & 2080 & \vspace{-0.6cm}\begin{dmath*} \left(\left(4 + 4\right) \cdot \left(4 + \left({4}^{4}\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 5 & 0.081s \\\hline
            4 & 2020 & \vspace{-0.6cm}\begin{dmath*} \left(4 + \left(\left(\left({4}^{4}\right) - 4\right) \cdot \left(4 + 4\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 6 & 0.086s \\\hline
            5 & 2980 & \vspace{-0.6cm}\begin{dmath*} \left(5 - \left(5 \cdot \left(5 - \left(5 \cdot \left((5 * (5 / 5))!\right)\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 7 & 0.378s \\\hline
            3 & 2080 & \vspace{-0.6cm}\begin{dmath*} \left(\left(((3 * 3) - 3)!\right) \cdot \left(3 - \left(\frac{3}{\left({3}^{3}\right)}\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 7 & 0.828s \\\hline
            2 & 2020 & \vspace{-0.6cm}\begin{dmath*} \left(2 \cdot \left(2 - \left(\left((2 * 2)!\right) \cdot \left(2 - \left(2 \cdot 22\right)\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 0.932s \\\hline
            2 & 2980 & \vspace{-0.6cm}\begin{dmath*} \left(2 \cdot \left(2 + \left(2 \cdot \left(\left((2 * 2)!\right) + \left(((2 + 2) + 2)!\right)\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 1.207s \\\hline
            2 & 2080 & \vspace{-0.6cm}\begin{dmath*} \left(2 \cdot \left(\left(2 \cdot \left(22 - 2\right)\right) \cdot \left(2 + \left((2 * 2)!\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 1.265s \\\hline
            2 & 2030 & \vspace{-0.6cm}\begin{dmath*} \left(\left(2 + 2\right) - \left(22 - \left({2}^{(22 / 2)}\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 2.142s \\\hline
            1 & 2020 & \vspace{-0.6cm}\begin{dmath*} \left(\left(1 + 1\right) \cdot \left(1111 \cdot \left(1 - \left(\frac{1}{11}\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 10 & 3.046s \\\hline
            5 & 2030 & \vspace{-0.6cm}\begin{dmath*} \left(5 - \left(\left(55 \cdot \left(\left(5 \cdot 5\right) - 5\right)\right) - \left({5}^{5}\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 3.955s \\\hline
            8 & 2080 & \vspace{-0.6cm}\begin{dmath*} \left(\frac{\left(8 \cdot 8\right)}{\left(\frac{\left(8 + 8\right)}{\left(8 + \left(8 \cdot \left(8 \cdot 8\right)\right)\right)}\right)}\right) \end{dmath*}\vspace{-0.85cm} & 8 & 4.780s \\\hline
            4 & 2030 & \vspace{-0.6cm}\begin{dmath*} \left(4 \cdot \left(\left(\frac{\left(\left({(4 + 4)}^{4}\right) - 4\right)}{\left(4 + 4\right)}\right) - 4\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 5.457s \\\hline
            4 & 2980 & \vspace{-0.6cm}\begin{dmath*} \left(4 \cdot \left(\left(((4 / 4) + 4)!\right) + \left({(4 + (4 / 4))}^{4}\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 5.613s \\\hline
            1 & 2030 & \vspace{-0.6cm}\begin{dmath*} \left(\left({(1 + 1)}^{11}\right) + \left(\left(1 + 1\right) \cdot \left(1 - \left(11 - 1\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 10 & 6.910s \\\hline
            1 & 2080 & \vspace{-0.6cm}\begin{dmath*} \left(\left({(1 + 1)}^{11}\right) - \left(1 - \left(\left(1 + \left(1 + 1\right)\right) \cdot 11\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 10 & 6.913s \\\hline
            0 & 2080 & \vspace{-0.6cm}\begin{dmath*} \left(\left(((((0!) + (0!)) + (0!))!)!\right) \cdot \left(\left(0!\right) - \left(\left({((0!) + ((0!) + (0!)))}^{(0 - ((0!) + (0!)))}\right) - \left(\left(0!\right) + \left(0!\right)\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 23 & 8.147s \\\hline
            5 & 2020 & \vspace{-0.6cm}\begin{dmath*} \left(\left({5}^{5}\right) - \left(5 + \left(55 \cdot \left(\left(5 \cdot 5\right) - 5\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 8 & 16.900s \\\hline
            0 & 2020 & \vspace{-0.6cm}\begin{dmath*} \left(\left(\left(0!\right) + \left(0!\right)\right) \cdot \left(\left(0!\right) + \left(\left(0!\right) - \left(\frac{\left((((((0!) + (0!)) + (0!))!) + (0!))!\right)}{\left(\left(0!\right) - \left((((0!) + (0!)) + (0!))!\right)\right)}\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 24 & 18.946s \\\hline
            0 & 2980 & \vspace{-0.6cm}\begin{dmath*} \left(\left(\left(0!\right) + \left(0!\right)\right) \cdot \left(\left(\left(0!\right) + \left(0!\right)\right) \cdot \left(\left(0!\right) + \left(\left(((((0!) + (0!)) + (0!))!)!\right) + \left((((0!) + (0!)) + ((0!) + (0!)))!\right)\right)\right)\right)\right) \end{dmath*}\vspace{-0.85cm} & 24 & 19.013s \\\hline
    \end{longtable}
\end{center}

\section{Code}

TBD

\section{Anhang}

\subsection{Rechnung zu \ref{theorem:tn_of_phi}}

%\textcolor{red}{Hier braucht es noch einen Anknüpfungspunkt. Greife mal noch die Ausgangsgleichung  wieder auf, etwa so:}
Der Beweis von Theorem \ref{theorem:tn_of_phi} führt auf folgende Abschätzung
    \[t_n \leq C_n \cdot 5^{n-1} < \frac{4^n}{(n+1)\sqrt{\pi n}} 5^{n-1} =  \frac{20^n}{5(n+1)\sqrt{\pi n}}\]

Hier kann \(n\) durch \(\measure{n}\) ersetzt werden.
Unter Verwendung der Abschätzung \(\measure{n} \leq \log_d(n) \cdot (d+4) + 2\) aus Corollarry \ref{corollary:phi_bound} ergeben sich folgende Umformungen:

%\textcolor{red}{Hier habe ich aber ein Verständnisproblem: Du ersetzt in Deiner ursprünglichen Beschreibung erstmal das $n$ in $20^n$ durch $\measure{\frac{a}{b}} $... warum? Danach wiederum ersetzt Du das $\frac{a}{b}$ im Zähler rechts wieder durch $n$, was dann doch wohl ein anderes $n$ ist??? Da steht ja dann $20^{\log_d(n)\cdot(d+4)+2}$ und nicht $20^{\log_d(\frac{a}{b})\cdot(d+4)+2}$.
%Dagegen steht links \(t_{\measure{n}}\), also eine Darstellung mit \(a\) und \(b\). Kriege ich gerade nicht klar. Die Rechnung danach muss ich nochmal im Detail durchgehen...}

\begin{align*}
    t_{\measure{\frac{a}{b}}}
    &< \frac{20^{\log_d(n)\cdot(d+4)+2}}{5\Big(\big(\log_d(n) \cdot (d+4)+2\big)+1\Big) \cdot \sqrt{\pi \cdot \log_d(n) \cdot (d+4) + 2}} \\
    &= \frac{\left(20^{\log_d(n)}\right)^{d+4}\cdot20^2}{5\Big(\big(\log_d(n) \cdot (d+4)+2\big)+1\Big) \cdot \sqrt{\pi \cdot \log_d(n) \cdot (d + 4) + 2}} \\
    &= 80\cdot\frac{\left(20^{\log_d(n)}\right)^{d+4}}{\big(\log_d(n) \cdot (d+4)+3\big) \cdot\sqrt{\pi \cdot \log_d(n)\cdot(d+4)+2}} \\
    &\leq 80\cdot\frac{\left(20^{\log_d(n)}\right)^{d+4}}{\log_d(n) \cdot d \cdot \sqrt{\pi \cdot \log_d(n) \cdot d}} \\
    &\leq 80\cdot\frac{\left(20^{\frac{\log_{20}(n)}{\log_{20}(d)}}\right)^{d+4}}{\log_d(n) \cdot d \cdot \sqrt{\log_d(n) \cdot d}} \\
    &\leq 80\cdot\frac{\left(n^{\frac{1}{\log_{20}(d)}}\right)^{d+4}}{\big(\log_d(n) \cdot d\big)^{\frac{3}{2}}} \\
    &\leq 80 \cdot n^{\frac{d+4}{\log_{20}(d)}} \cdot \big(\log_d(n) \cdot d\big)^{-\frac{3}{2}} \\
    &\in \mathcal{O}\left(n^{\frac{d+4}{\log_{20}(d)}} \cdot \big(\log_d(n) \cdot d\big)^{-\frac{3}{2}}\right) \\
\end{align*}

\end{document}