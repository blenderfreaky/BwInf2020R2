\documentclass{article}

\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=2.2cm,footskip=0.5cm]{geometry}

\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ntheorem}

\usepackage{lmodern}
%\usepackage{csquotes}

\usepackage{tikz}
\usetikzlibrary{chains}
\usetikzlibrary{matrix,positioning,calc}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{breqn}

\usepackage{longtable,array}
\newcolumntype{P}[1]{>{\raggedright\arraybackslash}p{#1}}

\usepackage{cite}

\usepackage{fancyhdr, lastpage}

\pagestyle{fancy}

\newcommand{\Fpage}{\thepage{}/\pageref{LastPage}}
\newcommand{\Ftitle}{Aufgabe 2 Geburtstag}
\newcommand{\Fauthor}{Nikolas Kilian}

\lhead{\Fauthor}
\rhead{\Ftitle}
\chead{}
\lfoot{}
\rfoot{}
\cfoot{\Fpage}

\setlength{\parskip}{.8em} 
\setlength{\parindent}{0pt}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}
%\usepackage{pxfonts}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

%
% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

\usepackage{url}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\normalfont}
\theoremseparator{.\,—}
\theoremsymbol{}
\newtheorem{proof-wo}{Beweis}
\theoremsymbol{\ensuremath{\color{lightgray}\blacksquare}}
\newtheorem{proof}{Beweis}


%\usepackage{courier}
%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{turqoisetypes}{rgb}{0.01,0.60,0.3}
\definecolor{background}{rgb}{0.95,0.95,0.95}
%\definecolor{background}{rgb}{.97,.97,.97}

\newcommand{\codesize}{\small}

\lstdefinelanguage{CSharp}{ % Better C# highlighting
language=[Sharp]C,
frame=lrbt,
%language=general,
backgroundcolor=\color{background},
captionpos=b,
numbers=left,
numberstyle=\tiny,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, get, set, from, select, package, deref},
%
emph=[0]{T,U,V,TToken},
emphstyle=[0]{\color{types}},
%
emph=[1]{Rational,NotSupportedException,List,HashSet,ITerm,BinaryOperation,UnaryOperation,BinaryOperator,UnaryOperator,DigitRepresenter},
emphstyle=[1]{\color{turqoisetypes}},
%
otherkeywords={=>,<,>},
emph=[2]{=>,<,>},
emphstyle=[2]{\bfseries},
%
emph=[3]{ParserResult},
emph=[3]{\color{turqoisetypes}\bfseries},
%
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\codesize\ttfamily,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

\lstMakeShortInline[
  language=CSharp,
  columns=fixed,]~

  \lstnewenvironment{lstcs}[1][]
  {\lstset{
      language=CSharp,
      breaklines=true,
      columns=fullflexible,
      caption={#1}
  }}
{}

\newcommand{\sidenote}[1]{&&|\ \text{#1}.}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand{\nldelims}[1]{\right.#1\left.}
\newcommand{\mnl}{\nldelims{\newline}}

\delimitershortfall=-1pt

% \let\svlp(
% \catcode`(=\active %
% \def(#1){\svlp#1)}
% \catcode`(=12 %
% \newcommand\pactive{\catcode`(=\active }
% \everymath{\pactive}
% \everydisplay{\pactive}

\usepackage{hyperref}
\usepackage{cleveref}

\begin{document}

%\textcolor{red}{Ich habe mal Deine Funktion von $\varphi_{d,b}$ auf $\Phi_d$ geändert und das $b$ darin weggelassen, dessen Bedeutung sich mir an dieser Stelle noch nicht erschließt. Kuck mal, ob Dir das so gefällt. Ich finde es besser. Wenn nicht: Ich habe Deine alte Definition auskommentiert, dann einfach meine wieder löschen. Wenn das $b$ wichtig ist, könntest Du vielleicht auch $\Phi_d^b$ nehmen, das finde ich noch besser leserlich als $\varphi_{d,b}$.}

\section{Lösungsidee}

Die Kernidee des Algorithmus besteht darin, alle Terme zu ermitteln, die durch \(n\)-fache Verwendung der gegebenen Ziffer und deren Verknüpfung mit sich selbst (wie in der Aufgabenstellung beschrieben) optimal ihren Wert darstellen.
Dies wird induktiv gelöst, wobei für die Errechnung der optimalen Terme mit Größe \(n\) alle kleineren Terme vorausgesetzt werden.
Zuerst werden alle infrage kommenden Terme mit Größe \(n\) gebildet. Hierzu werden alle Terme der Größe \(i\) mit allen Termen der Größe \(n-i\) unter Verwendung aller binärer Operationen gekreuzt.
Daraufhin werden alle Terme entfernt, deren Wert schon mit kleineren oder gleich großen Termen dargestellt wurde.
Um mit diesem Verfahren nun die Aufgabe zu lösen, ermittelt man solange größere Terme, bis der gesuchte Wert optimal von einem Term dargestellt wird.
Diese Vorangehensweise erlaubt es auch, mit der gleichen Ziffer Repräsentationen für mehrere Zahlen auf einmal zu finden, ohne dass sich die Laufzeit addiert.
Hierfür werden einfach größere und größere Terme ermittelt, bis alle Zahlen eine optimale Repräsentation erhalten haben.
Die Laufzeit, um mehrere Zahlen zu repräsentieren entspricht hierbei einfach der längsten Laufzeit, bei dem jede Zahl individuell durch den Algorithmus läuft.
%\textcolor{red}{Was meinst Du mit der Laufzeit der individuellen Zahlen? Findet sich hier vielleicht noch eine deutlichere Formulierung? Meinst Du so etwas wie 'die Laufzeit für die betreffenden Zahlen? Oder ähnliches?}

Auf ersten Blick scheint dieser Algorithmus eine exponentielle Komplexität zu besitzen, tatsächlich ist dem aber gar nicht so.
Im Folgenden wird die Komplexität dieses Verfahrens genauer betrachtet.

\newcommand{\fad}{\forall d, B:\ }
\newcommand{\measure}[1]{\Phi_{d}^{B}(#1)}

\subsection{Größenmaß-Funktion}

Zur Berechnung der Komplexität wird die Größenmaß-Funktion \(\Phi_{d}^{B} : \mathbb{Q} \to \mathbb{N}\) betrachtet, die die Anzahl an Instanzen der Ziffer \(d\) errechnet, die für die optimale Repräsentation beliebiger rationaler Zahlen benötigt werden. Dabei ist eine Konkatenierung bezüglich der Basis \(B\) möglich. Beispielsweise wird die Zahl \(11\) aus zwei mal der Ziffer \(1\)  zur Basis \(B=10\) generiert. Für die Größenmaß-Funktion gilt insbesondere \(\fad\measure{d} = 1\).

\begin{lemma}[Größenmaß für nicht-negative ganze Zahlen]\label{lemma:measure_linear_nonnegative}
    Für jede nicht-negative ganze Zahl \(n\) gilt:

    \[\measure{n} \leq n + 2\]
\end{lemma}
\begin{proof}
    \subsubsection*{Fall 1: \(n > 0\)}
    
    \(n > 0\) lässt sich als \(n\)-mal wiederholte Summierung von \(d\) darstellen:
    \[n = \frac{d+d+\ldots+d}{d} \implies \measure{n} \leq n + 1 < n + 2\]

    \subsubsection*{Fall 2: \(n = 0\)}
        
    \(n = 0\) lässt sich immer mit genau zwei Ziffern darstellen:
    \[n = d - d \implies \measure{n} \leq 2 = n + 2\]
\end{proof}
\begin{corollary}[Größenmaß für ganze Zahlen]\label{lemma:measure_linear}
    Für jede ganze Zahl \(n\) gilt:

    \[\fad \measure{n} \leq |n| + 3\]
\end{corollary}

\begin{proof}
    \subsubsection*{Fall 1: \(n \geq 0\)}

    Laut Lemma \ref{lemma:measure_linear_nonnegative} gilt:
    \[\measure{n} \leq n + 2 = |n| + 2 < |n| + 3\]

    \subsubsection*{Fall 2: \(n < 0\)}
        
    \(n < 0\) lässt sich als Differenz aus \(0 = d-d\) und \(|n| > 0\) darstellen:
    %\textcolor{red}{Meinst Du hier wirklich '\(0 = d-d\) und \(d\) darstellen' und nicht vielmehr aus '\(0 = d-d\) und |n|' darstellen? Der Bruch stellt doch den Betrag von $n$ dar ...}
    \[n = d - d - \frac{d+d+\ldots+d}{d} \implies \measure{n} \leq |n| + 3\]
    oder alternativ unter Verwendung von unärer Negation:
    \[n = -\frac{d+d+\ldots+d}{d} \implies \measure{n} \leq |n| + 1 < |n| + 3\]
\end{proof}

\begin{lemma}[Größenmaß für binäre Operationen]\label{lemma:phi_binary}
    Für jeden binären Operator \(\circ : \mathbb{Q} \times \mathbb{Q} \to \mathbb{Q}\) gilt für alle \(a\in\mathbb{Q},\ b\in\mathbb{Q}\):

    \[\measure{a \circ b} \leq \measure{a} + \measure{b}\]

    Die Anwendung der Größenmaß-Funktion auf binäre Operationen lässt sich also immer durch Addition der Größenmaße der Operanden abschätzen.
\end{lemma}
\begin{proof}
    Die rationalen Zahlen \(a\) und \(b\) lassen sich mit \(\measure{a}\) bzw. \(\measure{b}\) Ziffern ausdrücken, also lässt sich \(a \circ b\) durch Anwendung der Operation \(\circ\) auf die Terme für \(a\) und \(b\) mit \(\measure{a} + \measure{b}\) oder weniger Ziffern ausdrücken.
\end{proof}

\begin{corollary}[Größenmaß für rationale Zahlen]\label{corollary:phi_rational}
    Für jede rationale Zahl \(\frac{a}{b}\in\mathbb{Q},\ a\in\mathbb{Z},\ b\in\mathbb{Z}^+\) gilt:

    \[\measure{\frac{a}{b}} \leq \measure{a} + \measure{b}\]
\end{corollary}
\begin{proof}
    \(\frac{a}{b}\) ist das Ergebnis der Anwendung des binären Divisions-Operators auf \(a\) und \(b\), somit lässt es sich laut Lemma \ref{lemma:phi_binary} mit \(\measure{a} + \measure{b}\) oder weniger Ziffern ausdrücken.
\end{proof}
%\textcolor{red}{Das ist doch hier ein anderes 'b' als das in Deiner ursprünglichen Definition von $\varphi_{d,b}$? Ich finde, Du solltest Dein 'b' unbedingt noch erläutern.}
\begin{theorem}[Genauere obere Grenze des Größenmaßes für positive ganze Zahlen]\label{theorem:accurate_bound}
    Für jede positive ganze Zahl \(n\) gilt:
    
        \[\measure{n} \leq \log_d(n) \cdot (d+4)\]
\end{theorem}
\begin{proof}
    Jede positive ganze Zahl lässt sich im Horner-Schema darstellen.
    Betrachte man die natürliche Zahl \(n\) in Basis \(d\).

        \begin{equation}\label{eqn:horner_schema}
            n = a_1 + d (a_2 + d (\ldots d a_k)),\ a_i\in\mathbb{N},\ 0 \leq a_i < d
        \end{equation}

    Hierbei ist es anzumerken, dass keine Basis 1 existiert und dies somit für \(d=1\) nicht anwendbar ist.
    Im folgenden wird zuerst der generelle Fall betrachtet.
    Aus Gleichung \ref{eqn:horner_schema} lässt sich ablesen:

    \begin{align*}
        \measure{n} 
        &\leq \measure{a_1 + d (a_2 + d (\ldots d a_k))} \sidenote{\ref{lemma:phi_binary}} \\
        &\leq \measure{a_1} + \measure{d} + \measure{a_2} + \measure{d} + \ldots + \measure{d} + \measure{a_k} \\
        &= (k-1)\cdot\measure{d} + \sum_{i=1}^k \measure{a_i} \numberthis\label{eqn:semi_accurate_bound}
    \end{align*}
    
    Da \(0 \leq a_i < d\) gilt, folgt mit Lemma \ref{lemma:measure_linear_nonnegative} für jedes \(a_i\): \(\measure{a_i} \leq d + 2\).
    Zusammen mit \(\measure{d} = 1\) folgt aus Abschätzung \ref{eqn:semi_accurate_bound}:
    
%\textcolor{red}{Bei der nachfolgenden Auflistung würde ich die erste Zeile weglassen, denn diese ist nur eine Dopplung Deiner Gleichung (2) obendrüber, fange gleich mit der nächsten Ungleichung an}
    \begin{align*}
        \measure{n} 
        &\leq (k-1) \cdot 1 + \sum_{i=1}^k (d+2) \\
        &\leq (k-1) + k \cdot (d+2) \\
        &\leq k + k \cdot (d+2) = k \cdot (d+3) \\
    \end{align*}
Bei der Repräsentation mit dem Horner-Schema gilt \(k = \lfloor \log_d(n) \rfloor\), somit folgt:
        \[\measure{n} \leq k \cdot (d+3) = \lfloor \log_d(n) \rfloor \cdot (d+3) \leq \log_d(n) \cdot (d+3)\]

%\textcolor{red}{Warum hier nochmal der Wechsel von $d+3$ zu $d+4$. Das erschließt sich an dieser Stelle für mich nicht.}
Das Problem der non-existenten Basis für den Spezialfall \(d = 1\) kann durch den folgenden Trick umgangen werden:
Anstelle von \(d = 1\) wird die  Basis \(2 = 1 + 1 = d + d\) betrachtet.   
In Abschätzung \ref{eqn:semi_accurate_bound} muss dann nur \(\measure{d}\) durch \(\measure{d + d} = 2\cdot\measure{d}\) ersetzt werden:
    \[\measure{n} \leq (k-1) \cdot 2 \cdot \measure{d} + \sum_{i=1}^k \measure{a_i}\]
und es folgt analog zu oben:
    \begin{align*}
        \measure{n} 
        &\leq k \cdot (d+4) \\
        &\leq \log_d(n) \cdot (d+4) \\
    \end{align*}

Somit gilt sowohl im generellen Fall als auch im Spezialfall die Abschätzung \(\measure{n} \leq \log_d(n) \cdot (d+4)\).
\end{proof}

\begin{corollary}[Genauere obere Grenze des Größenmaßes für ganze Zahlen]\label{corollary:phi_bound}
    Für jede ganze Zahl \(n\) gilt:
    
        \[\measure{n} \leq \log_d(n) \cdot (d+4) + 2\]
\end{corollary}
\begin{proof}
    Analog zum Beweis von Lemma \ref{lemma:measure_linear}.
\end{proof}

\subsection{Anzahl an Termen}

Die Anzahl an Termen mit \(n\) Ziffern sei definiert als \(t_n\).
Bei Größe \(0\) gibt es beispielsweise \(t_0 = 0\) Terme, bei \(1\) gibt es \(t_1 = 1\) Terme und bei \(2\) gibt es \(t_2 = 6\) Terme (\(d; dd; d+d; d-d; d \cdot d; d \div d\)).

\begin{theorem}[Abschätzung für \(t_n\)]\label{theorem:tn_bound}
    Die Anzahl an Termen lässt sich wie folgt nach oben abschätzen

        \[t_n \leq C_n \cdot 5^{n-1}\,,\]
     wobei \(C_n\) die Catalan Zahlen bezeichnet.
\end{theorem}
\begin{proof}
    Terme von Größe \(n\) können als volle Binärbäume mit \(n\) Blättern aufgefasst werden, wobei jedes Blatt eine Ziffer oder eine Wiederholung der Ziffer darstellt und jeder Knoten eine binäre Operation zwischen seinen zwei Kindern darstellt.
    Am Beispiel für \(6 = (1+1)\cdot(1+(1+1))\):
    \begin{center}
        \begin{tikzpicture}[level/.style={sibling distance = 4cm/#1,  level distance = 0.8cm}] 
        \node [circle,draw] {$\cdot$}
            child{ node  [circle,draw] {$+$}
                child{ node  [circle,draw] {$1$}} 
                child{ node  [circle,draw] {$1$}} 
            }
            child{ node  [circle,draw] {$+$} 
                child{ node  [circle,draw] {$1$}} 
                child{ node  [circle,draw] {$+$}
                    child{ node  [circle,draw] {$1$}} 
                    child{ node  [circle,draw] {$1$}} 
                } 
            }
        ; 
        \end{tikzpicture}
    \end{center}
    Hierbei werden auch invalide Terme mit Division durch Null wie \(1 \div (1-1)\) mit betrachtet.
    Jedoch sind alle validen Terme wie oben repräsentierbar, so dass die Anzahl solcher Binärbäume größer als die Anzahl valider Terme ist und somit geeignet für eine obere Abschätzung.
    Nachfolgend werden zunächst nur Terme ohne Konkatenierung von Ziffern betrachtet.

    Betrachte man nun zuerst die Anzahl solcher Binärbäume.
    Die Anzahl an vollen Binärbäumen mit \(n\) Blättern wird durch die Catalan Zahlen \(C_n\) beschrieben.
    Die Catalan Zahlen beschreiben jedoch nur die Anzahl an Binärbäumen, nicht die Anzahl an Binärbäumen mit Operatoren in den Knoten.
    In einem vollen Binärbaum mit \(n\) Blättern gibt es \(n-1\) Knoten bzw. \(n-1\) Operatoren.
    Bei \(4\) Operatoren heißt das, dass die Anzahl an Kombinationen von Operatoren \(4^{n-1}\) beträgt.
    Folglich ist die Anzahl an Binärbäumen mit Operatoren in den Knoten das Produkt dieser beiden Zahlen: \(C_n \cdot 4^{n-1}\).

    Um nun auch die Konkatenierung von Ziffern zu berücksichtigen, kann man sich einen Konkatenierungs-Operator vorstellen:
    \[l \circ r = B \cdot l + r \,,\quad\quad\text{bspw.: } 1\circ1 = B + 1 = 10 + 1 = 11\]
    
    Dieser würde natürlich auch ``unerlaubte'' Konkatenierungen erlauben, beispielsweise für \(B=10\):
     \[(4+4+4) \circ (4\cdot4) = 12 \circ 16 = 12B + 16 = 120 + 16 = 136\]

    Jedoch werden so alle validen Konkatenierungen und mehr abgebildet, weshalb er für eine Abschätzung nach oben geeignet ist.
    Nun lässt sich die vorherige Herangehensweise analog durchführen, jedoch diesmal mit \(5\) Operatoren.
    Somit ist die Anzahl an Termen der Größe \(n\) kleiner gleich \(C_n \cdot 5^{n-1}\).
\end{proof}

\begin{theorem}[Anzahl zu betrachtender Terme]\label{theorem:tn_of_phi}
    Aus Corollary \ref{corollary:phi_bound}, \ref{corollary:phi_rational} und Theorem \ref{theorem:tn_bound} folgt, dass für jede rationale Zahl \(n\in\mathbb{Q}\) gilt:

        \[\sum_{i=0}^{\measure{n}} t_i \in \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}\]

    Was bedeutet, dass die Anzahl an Termen, die zur Darstellung von \(n\) die Ziffer minimal verwenden, polynomial zu \(n\) abschätzbar ist.
\end{theorem}
\begin{proof}
    Laut Theorem \ref{theorem:tn_bound} gilt:

        \[t_n \leq C_n \cdot 5^{n-1}\]

    Für die Catalan Zahlen gilt folgende obere Abschätzung\footnote{Siehe Seite 212: \url{https://www.sciencedirect.com/science/article/pii/S0195669886800245}}:

        \[C_n < \frac{4^n}{(n+1)\sqrt{\pi n}}\]

    Somit folgt:

        \[t_n \leq C_n \cdot 5^{n-1} < \frac{4^n}{(n+1)\sqrt{\pi n}} 5^{n-1} = \frac{4^n \cdot 5^n}{5(n+1)\sqrt{\pi n}} = \frac{20^n}{5(n+1)\sqrt{\pi n}}\]

    Nun kann man um die Anzahl der für \(n\) zu betrachtender Terme \(\measure{n}\) statt \(n\) einsetzen, um die Anzahl aller Terme zu bestimmen, die genauso viele Ziffern wie die optimale Repräsentation von \(n\) haben.
    Mit Corollary \ref{corollary:phi_bound} gilt nach einer ganzen Reihe von Umformungen (siehe Anhang):
    
    \begin{equation}
        t_{\measure{n}}
        = \mathcal{O}\Big(n^{\frac{d+4}{\log_{20}(d)}} \cdot \underbrace{\big(\log_d(n) \cdot d\big)^{-\frac{3}{2}}}_{\text{streng monoton fallend}}\Big) \\
        = \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}
    \end{equation}

    Da die Ziffer \(d\) dabei immer konstant ist, ist auch \(\alpha\) konstant.
    Somit ist \(t_{\measure{n}}\) nach oben polynomial abschätzbar.
    \pagebreak
    
    Da der Algorithmus induktiv arbeitet, werden zur Bestimmung der Terme von Größe \(n\) die Terme von Größe \(n-1\) benötigt.
    Daher entspricht die Anzahl der Terme, die für eine optimale Repräsentation von \(n\) zu betrachten sind, der Summe der Anzahl aller Terme mit genauso vielen oder weniger Ziffern wie die optimale Repräsentation \(n\), also \(\sum_{i=0}^{\measure{n}} t_i\). Da die Komplexitätsklasse einer Summe von Elementen der polynomialen Komplexitätsklasse wieder die polynomiale Komplexitätsklasse ist, ist diese Summe somit auch polynomial:

    \[\sum_{i=0}^{\measure{n}} t_i \in \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}\]
\end{proof}

Da immer alle Ziffern (außer 0) verwendet werden, muss diese Komplexität für alle Ziffern addiert werden.
Somit ist die Komplexität eine Summe aus Potenzen, also ebenfalls eine Potenz:

\[t_{\measure{n}} \in \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\max_{0 < d \leq 9}\frac{d+4}{\log_{20}(d)}\]

%All das mag heißen, dass auch wenn quasi purer Brute-Force verwendet wird, die Komplexität polynomial ist und somit auch die Komplexität des obigen Algorithmus.
Auch wenn quasi purer Brute-Force verwendet wird, so belegen diese Überlegungen dennoch, dass eine polynomiale Komplexität vorliegt.
Da der eigentliche Algorithmus durch die Eliminierung von Duplikaten noch einmal stärker optimiert ist, ist dessen Komplexität natürlich auch polynomial.

\subsection{Exponenten und Fakultäten}

Um den Algorithmus auf Exponenten und Fakultäten zu erweitern, kann zuerst Exponentiation als zusätzlicher binärer Operator wie Addition und Multiplikation hinzugefügt werden.
Dabei bleibt die Komplexität analog zu vorher polynomial, nur zu einem größeren Exponenten.
%\textcolor{red}{Schau mal hier, ob das sinngemäß noch das ist, was Du sagen wolltest ... ich hab den Text vorweg etwas verändert}.

Für die Hinzunahme von Fakultäten ist dies jedoch nicht so leicht.
Zunächst lässt sich Fakultät relativ leicht in den Algorithmus einbauen, wobei jeder neue optimale Term noch einmal mit einer Fakultät hinten zu der Liste aller optimalen Terme addiert wird.
Das Problem besteht allerdings darin, dass Fakultät eine unäre Operation ist, weshalb sie unabhängig von der Anzahl an Instanzen der Ziffer beliebig oft verwendbar ist; beispielsweise ist \(((((d!)!)!)!)!\) in der Theorie erlaubt.
Betrachtet man jedoch die Werte der Fakultäts-Funktion, so fällt auf, dass dort sehr schnell immens große Werte entstehen; beispielsweise ist \((5!)!=120!\), was eine Zahl mit 199 Ziffern ist.
Dass diese Werte nur sehr selten brauchbar sind, ist relativ offensichtlich.

Zur Umgehung dieses Problems habe ich daher ein Limit eingefügt, das Fakultäten von Zahlen größer \(20\) verbietet, wobei \(20!\) die größte durch signierte 64-Bit Integer darsellbare Fakultät ist.
%Zur Umgehung dieses Problems habe ich daher ein Limit eingefügt, das Fakultäten von Zahlen größer der arbiträr gewählten Grenze \(80\) verbietet.
Somit ist \((4!)!\) gerade noch erlaubt, jedoch \((5!)!\) verboten.
Dies lässt sich auch leicht implementieren, wobei jeder neue Term mit Wert \(x < 80\) den neuen Term \(x!\) rekursiv einfügt.
Dabei muss man jedoch noch darauf achten, dass keine Endlosschleifen auftauchen: \(1 = 1! = \ldots = ((1!)!)!\)

Es lässt sich erkennen, dass hierbei höchstens zwei Fakultäten in Reihe auftreten können.
Das bedeutet, dass für jeden neu gefundenen optimalen Term noch (höchstens) zwei weitere Terme addiert werden.
Dies bedeutet, dass sich die Rechenzeit (höchstens) verdreifacht, und somit immer noch polynomial ist.

Im Hinblick auf Fakultäten ist noch bemerkenswert, dass nun auch die Ziffer \(0\) verwendet werden kann:
\(0! = 1\).
Die Beispiele unten enthalten daher auch Lösungen mit der Ziffer \(0\).

\section{Umsetzung}

Der Algorithmus wurde in C\# 8.0 mit .NET Core 3.1 implementiert.
Der Code ist in zwei Projekte geteilt;
~Afg2Geburtstag.CLI~ und ~Afg2Geburtstag~.
~Afg2Geburtstag.CLI~ kümmert sich um das Konsolen-Interface und ruft ~Afg2Geburtstag~ auf, was den eigentlichen Algorithmus enthält.
~Afg2Geburtstag~ definiert einige Typen:

\begin{description}
    \item[Rational] definiert rationale Zahlen und Operationen auf diesen.
    \item[ITerm] repräsentiert eine Schnittstelle für beliebige Terme mit einem ~BigRational~ Wert. Wird von ~BigRational~ implementiert.
    \item[UnaryOperation] repräsentiert eine unäre Operation auf einem ~ITerm~ und implementiert selbst ~ITerm~.
    \item[BinaryOperation] repräsentiert eine binäre Operation zwischen zwei ~ITerm~s und implementiert selbst ~ITerm~.
    \item[DigitRepresenter] enthält den Kernalgorithmus für eine Ziffer und mehrere Zielzahlen.
\end{description}

~UnaryOperation~ und ~BinaryOperation~ speichern als Optimierung ihren berechneten Wert und Hashcode.
Weiterhin sind die Operanden der beiden Typen ~ITerm~ Instanzen und somit Referenztypen.
Dies bedeutet, dass jede Operation nur einmal gespeichert wird und nicht in anderen Operationen, die sie verwenden, gedoppelt wird.

In ~DigitRepresenter~, worin der Hauptalgorithmus implementiert wird, werden an vielen Stellen Hashsets verwendet, um schnelle Lookups zu erlauben.
Spezifischer, da ~HashSet<T>~ nicht Thread-Safe ist, verwendet der Code ~ConcurrentDictionary<T, byte>~, wobei der ~byte~-Wert ignoriert wird.

Für Informationen zur Verwendung des Programms kann ~Afg2Geburtstag.exe --help~ ausgeführt werden.

\section{Beispiele}

\subsection{Ohne Exponenten und Fakultäten}

Argumente:
~--targets 2020, 2030, 2080, 2980 --digits 1,2,3,4,5,6,7,8,9 --sync --latex~

% Targets: 2020, 2030, 2080, 2980
% Digits: 1, 2, 3, 4, 5, 6, 7, 8, 9
% Base: 10
%
%\textcolor{red}{beim Header sind die senkrechten Striche teilweise zu kurz, bzw. die ersten beiden zu lang.}
\begin{center}
    \begin{longtable}{ | l | l | p{9.5cm} | l | l | }
    \hline \textbf{Digit} & \textbf{Value} & \textbf{Term} & \textbf{Digit Usages} & \textbf{Time} \\\hline
        1 & 2020 & \( \left(\left(1 + 1\right) \cdot \left(\frac{\left(11111 - 1\right)}{11}\right)\right) \) & 10 & 0.092s \\\hline
        1 & 2020 & \( \left(\frac{\left(\left(1 + 1\right) \cdot \left(11111 - 1\right)\right)}{11}\right) \) & 10 & 0.092s \\\hline
        1 & 2080 & \( \left(\left(1 + \left(\left(\left(1 + 1\right) \cdot \left(1 - 111\right)\right) + 11\right)\right) \cdot \left(1 - 11\right)\right) \) & 12 & 0.124s \\\hline
        1 & 2030 & \( \left(\left(11 - 1\right) \cdot \left(1 + \left(\left(1 + 1\right) \cdot \left(1 - \left(11 - 111\right)\right)\right)\right)\right) \) & 12 & 0.126s \\\hline
        2 & 2020 & \( \left(2 \cdot \left(\left(\left(2 + \left(2 \cdot 22\right)\right) \cdot 22\right) - 2\right)\right) \) & 8 & 0.008s \\\hline
        2 & 2080 & \( \left(\left(2 \cdot \left(2 \cdot \left(22 - 2\right)\right)\right) \cdot \left(2 + \left(2 + 22\right)\right)\right) \) & 9 & 0.010s \\\hline
        2 & 2030 & \( \left(\left(2 \cdot \left(2 + \left(\left(2 + \left(2 \cdot 22\right)\right) \cdot 22\right)\right)\right) + 2\right) \) & 9 & 0.024s \\\hline
        2 & 2980 & \( \left(\left(2 - \left(\left(2 + 22\right) \cdot \left(\left(2 \cdot \left(2 - 22\right)\right) - 22\right)\right)\right) \cdot 2\right) \) & 11 & 0.133s \\\hline
        3 & 2020 & \( \left(\left(\left(3 + 333\right) \cdot \left(3 + 3\right)\right) + \left(3 + \left(\frac{3}{3}\right)\right)\right) \) & 9 & 0.009s \\\hline
        3 & 2080 & \( \left(\left(33 \cdot \left(33 + \left(33 - 3\right)\right)\right) + \left(\frac{3}{3}\right)\right) \) & 9 & 0.014s \\\hline
        3 & 2030 & \( \left(33 - \left(\left(\frac{3}{3}\right) - \left(333 \cdot \left(3 + 3\right)\right)\right)\right) \) & 9 & 0.015s \\\hline
        3 & 2980 & \( \left(\left(\frac{3}{3}\right) + \left(3 \cdot \left(3 + \left(33 \cdot \left(33 - 3\right)\right)\right)\right)\right) \) & 9 & 0.026s \\\hline
        4 & 2080 & \( \left(\left(44 - 4\right) \cdot \left(4 + \left(4 + 44\right)\right)\right) \) & 7 & 0.002s \\\hline
        4 & 2020 & \( \left(4 - \left(\left(4 + 4\right) \cdot \left(4 - \left(4 \cdot \left(4 \cdot \left(4 \cdot 4\right)\right)\right)\right)\right)\right) \) & 8 & 0.004s \\\hline
        4 & 2980 & \( \left(4 - \left(\left(4 \cdot 4\right) - \left(\left(4 + \left(4 \cdot \left(4 \cdot 4\right)\right)\right) \cdot 44\right)\right)\right) \) & 9 & 0.009s \\\hline
        4 & 2030 & \( \left(\left(4 \cdot \left(\left(4 \cdot \left(4 \cdot \left(4 \cdot \left(4 + 4\right)\right)\right)\right) - 4\right)\right) - \left(\frac{\left(4 + 4\right)}{4}\right)\right) \) & 10 & 0.192s \\\hline
        5 & 2080 & \( \left(\left(5 + \left(\frac{55}{5}\right)\right) \cdot \left(5 + \left(5 \cdot \left(5 \cdot 5\right)\right)\right)\right) \) & 8 & 0.004s \\\hline
        5 & 2980 & \( \left(\left(5 + \left(5 + \left(55 \cdot 55\right)\right)\right) - 55\right) \) & 8 & 0.004s \\\hline
        5 & 2030 & \( \left(\left(5 \cdot \left(5 + \left(\left(\left(5 \cdot 5\right) + 55\right) \cdot 5\right)\right)\right) + 5\right) \) & 8 & 0.007s \\\hline
        5 & 2020 & \( \left(\left(5 \cdot \left(5 + \left(\left(\left(5 \cdot 5\right) + 55\right) \cdot 5\right)\right)\right) - 5\right) \) & 8 & 0.007s \\\hline
        6 & 2080 & \( \left(\left(\left(\frac{\left(6 + 6\right)}{6}\right) + \left(\left(6 \cdot 6\right) - 6\right)\right) \cdot \left(66 - \left(\frac{6}{6}\right)\right)\right) \) & 10 & 0.068s \\\hline
        6 & 2030 & \( \left(\left(\left(\frac{6}{6}\right) - 6\right) \cdot \left(\left(\frac{\left(6 - 66\right)}{6}\right) - \left(6 \cdot 66\right)\right)\right) \) & 10 & 0.073s \\\hline
        6 & 2020 & \( \left(\left(6 - \left(\frac{6}{6}\right)\right) \cdot \left(\left(\frac{\left(6 + 6\right)}{6}\right) + \left(6 + \left(6 \cdot 66\right)\right)\right)\right) \) & 10 & 0.132s \\\hline
        6 & 2980 & \( \left(\left(\left(6 + \left(\frac{6}{6}\right)\right) \cdot \left(\left(6 \cdot \left(6 \cdot \left(6 + 6\right)\right)\right) - 6\right)\right) - \left(\frac{\left(6 + 6\right)}{6}\right)\right) \) & 11 & 0.466s \\\hline
        7 & 2030 & \( \left(\left(7 \cdot \left(7 + \left(7 \cdot \left(\left(7 \cdot 7\right) - 7\right)\right)\right)\right) - 77\right) \) & 8 & 0.013s \\\hline
        7 & 2020 & \( \left(\left(\frac{77}{7}\right) + \left(7 \cdot \left(\left(7 \cdot \left(\left(7 \cdot 7\right) - 7\right)\right) - 7\right)\right)\right) \) & 9 & 0.015s \\\hline
        7 & 2080 & \( \left(\frac{\left(7 + \left(77 \cdot \left(\left(\left(7 + 7\right) \cdot \left(7 + 7\right)\right) - 7\right)\right)\right)}{7}\right) \) & 9 & 0.029s \\\hline
        7 & 2980 & \( \left(\left(\left(7 \cdot \left(7 + \left(77 + \left(7 \cdot \left(7 \cdot 7\right)\right)\right)\right)\right) - \left(\frac{\left(7 + 7\right)}{7}\right)\right) - 7\right) \) & 11 & 0.505s \\\hline
        8 & 2080 & \( \left(\left(8 + \left(8 + \left(8 + 8\right)\right)\right) \cdot \left(\left(\frac{8}{8}\right) + \left(8 \cdot 8\right)\right)\right) \) & 8 & 0.004s \\\hline
        8 & 2020 & \( \left(\frac{\left(8 - \left(8 \cdot \left(8 - \left(8 \cdot \left(8 \cdot 8\right)\right)\right)\right)\right)}{\left(\frac{\left(8 + 8\right)}{8}\right)}\right) \) & 9 & 0.023s \\\hline
        8 & 2030 & \( \left(\left(\frac{\left(8 - 88\right)}{8}\right) - \left(8 - \left(8 \cdot \left(\left(8 + 8\right) \cdot \left(8 + 8\right)\right)\right)\right)\right) \) & 10 & 0.106s \\\hline
        8 & 2980 & \( \left(\left(\frac{8}{8}\right) + \left(\frac{\left(8 + \left(\left(8 \cdot \left(8 \cdot \left(8 \cdot 8\right)\right)\right) \cdot \left(8 \cdot 8\right)\right)\right)}{88}\right)\right) \) & 11 & 0.345s \\\hline
        9 & 2080 & \( \left(\left(\frac{9}{9}\right) + \left(\left(9 + \left(\frac{\left(9 + 99\right)}{9}\right)\right) \cdot 99\right)\right) \) & 9 & 0.014s \\\hline
        9 & 2020 & \( \left(\frac{\left(\left(\left(\frac{99}{9}\right) + 999\right) \cdot \left(9 + 9\right)\right)}{9}\right) \) & 9 & 0.016s \\\hline
        9 & 2980 & \( \left(\left(\frac{9}{9}\right) + \left(\left(\left(9 \cdot \left(9 + \left(\left(9 + 9\right) \cdot \left(9 + 9\right)\right)\right)\right) - 9\right) - 9\right)\right) \) & 10 & 0.049s \\\hline
        9 & 2030 & \( \left(\left(\left(9 \cdot 9\right) - \left(\frac{99}{9}\right)\right) \cdot \left(9 + \left(9 + \left(\frac{99}{9}\right)\right)\right)\right) \) & 10 & 0.088s \\\hline
\end{longtable}
\end{center}

\subsection{Mit Exponenten und Fakultäten}

Argumente:
~--targets 2020, 2030, 2080, 2980~
~--digits 0,1,2,3,4,5,6,7,8,9~\\
~--exponentiation --factorial --sync --latex~

% Targets: 2020, 2030, 2080, 2980
% Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
% Base: 10
% Exponentiation Factorial
\begin{center}
    \begin{longtable}{ | l | l | p{9.5cm} | l | l | }
    \hline \textbf{Digit} & \textbf{Value} & \textbf{Term} & \textbf{Digit Usages} & \textbf{Time} \\\hline
        0 & 2980 & \( \left(\left(\left(0!\right) + \left(\left(0!\right) + \left(\left(0!\right) + \left(0!\right)\right)\right)\right) \mnl\quad\cdot \left(\left(0!\right) + \left(\left((((0!) + (0!)) + ((0!) + (0!)))!\right) \nldelims{\nldelims{\mnl}}\ \ + \left(((((0!) + (0!)) + (0!))!)!\right)\right)\right)\right) \) & 24 & 0.476s \\\hline
        0 & 2080 & \( \left(\left({((0!) + (0!))}^{(((((0!) + (0!)) + (0!))!) - (0!))}\right) \mnl\quad\cdot \left(\left(0!\right) + \left({((0!) + (0!))}^{((((0!) + (0!)) + (0!))!)}\right)\right)\right) \) & 24 & 0.487s \\\hline
        0 & 2020 & \( \left(\left(\left(0!\right) + \left(0!\right)\right) \cdot \left(\left(0!\right) + \left(\left(0!\right) \nldelims{\nldelims{\mnl}}\ \ - \left(\frac{\left(((0!) + ((((0!) + (0!)) + (0!))!))!\right)}{\left(\left(0!\right) - \left((((0!) + (0!)) + (0!))!\right)\right)}\right)\right)\right)\right) \) & 24 & 0.490s \\\hline
        0 & 2030 & \( \left(\left(0!\right) + \left(\left(\left(\left(0!\right) + \left(\left(0!\right) + \left(0!\right)\right)\right) \cdot \left(((0!) + ((0!)+ ((((0!) \nldelims{\nldelims{\nldelims{\mnl}}}\ \ + (0!)) + ((0!) + (0!)))!)))^{((0!) + (0!))}\right)\right) + \left(0!\right)\right)\right) \) & 26 & 0.838s \\\hline
        1 & 2080 & \( \left(\left(\left(1 + \left(1 + 1\right)\right) \cdot 11\right) + \left(\left({(1 + 1)}^{11}\right) - 1\right)\right) \) & 10 & 0.037s \\\hline
        1 & 2030 & \( \left(\left(\left(\left({(1 + 1)}^{11}\right) - 1\right) - \left(((1 + 1) + 1)!\right)\right) - 11\right) \) & 10 & 0.037s \\\hline
        1 & 2020 & \( \left(\frac{\left(\left(11111 - 1\right) \cdot \left(1 + 1\right)\right)}{11}\right) \) & 10 & 0.047s \\\hline
        1 & 2980 & \( \left(\left(\left(((((1 + 1) + 1)!) + 1)!\right) - \left(\left({(1 + 1)}^{11}\right) + 11\right)\right) - 1\right) \) & 11 & 0.180s \\\hline
        2 & 2080 & \( \left(\left({(2 * 22)}^{2}\right) + \left({(((2 * 2)!) / 2)}^{2}\right)\right) \) & 8 & 0.019s \\\hline
        2 & 2030 & \( \left(\left(\left({2}^{(22 / 2)}\right) - 22\right) + \left(2 + 2\right)\right) \) & 8 & 0.020s \\\hline
        2 & 2020 & \( \left(\left(\left({2}^{(22 / 2)}\right) - \left(2 + 2\right)\right) - \left((2 * 2)!\right)\right) \) & 8 & 0.039s \\\hline
        2 & 2980 & \( \left(\left({(2 * ((2 * 2)!))}^{2}\right) + \left({(2 + ((2 * 2)!))}^{2}\right)\right) \) & 8 & 0.043s \\\hline
        3 & 2080 & \( \left(\left(3 \cdot \left(\left(((3 * 3) - 3)!\right) - \left({3}^{3}\right)\right)\right) + \left(\frac{3}{3}\right)\right) \) & 8 & 0.077s \\\hline
        3 & 2030 & \( \left(\left(33 - \left(\frac{3}{3}\right)\right) + \left(333 \cdot \left(3 + 3\right)\right)\right) \) & 9 & 0.188s \\\hline
        3 & 2020 & \( \left(\left(3 + \left(\left(3 + 3\right) \cdot \left(3 + 333\right)\right)\right) + \left(\frac{3}{3}\right)\right) \) & 9 & 0.326s \\\hline
        3 & 2980 & \( \left(\left(\frac{3}{3}\right) - \left(3 \cdot \left(\left(\left(3 - 33\right) \cdot 33\right) - 3\right)\right)\right) \) & 9 & 0.386s \\\hline
        4 & 2080 & \( \left(\left(4 + 4\right) \cdot \left(4 + \left({4}^{4}\right)\right)\right) \) & 5 & 0.001s \\\hline
        4 & 2020 & \( \left(4 + \left(\left(\left({4}^{4}\right) - 4\right) \cdot \left(4 + 4\right)\right)\right) \) & 6 & 0.002s \\\hline
        4 & 2980 & \( \left(\left(\left(\left({4}^{4}\right) - 4\right) \cdot \left(4 + \left(4 + 4\right)\right)\right) - 44\right) \) & 8 & 0.052s \\\hline
        4 & 2030 & \( \left(\left({4}^{4}\right) - \left(\left(\frac{\left(4 + 4\right)}{4}\right) - \left(4 \cdot 444\right)\right)\right) \) & 9 & 0.174s \\\hline
        5 & 2980 & \( \left(\left(5 - \left(5 \cdot \left(5 + \left(5 \cdot 5\right)\right)\right)\right) + \left({5}^{5}\right)\right) \) & 7 & 0.005s \\\hline
        5 & 2080 & \( \left(\left(5 + \left(5 \cdot \left(5 \cdot 5\right)\right)\right) \cdot \left(5 + \left(\frac{55}{5}\right)\right)\right) \) & 8 & 0.035s \\\hline
        5 & 2030 & \( \left(\left(5 + \left({5}^{5}\right)\right) - \left(\left(\left(5 \cdot 5\right) - 5\right) \cdot 55\right)\right) \) & 8 & 0.036s \\\hline
        5 & 2020 & \( \left(\left(5 \cdot \left(5 + \left(5 \cdot \left(\left(5 \cdot 5\right) + 55\right)\right)\right)\right) - 5\right) \) & 8 & 0.062s \\\hline
        6 & 2030 & \( \left(\left(\left(\frac{6}{6}\right) - \left(6 \cdot 6\right)\right) \cdot \left(6 - \left({((6 + 6) / 6)}^{6}\right)\right)\right) \) & 9 & 0.232s \\\hline
        6 & 2080 & \( \left(\left(\left(\frac{6}{6}\right) - 66\right) \cdot \left(\left(6 - \left(6 \cdot 6\right)\right) - \left(\frac{\left(6 + 6\right)}{6}\right)\right)\right) \) & 10 & 0.721s \\\hline
        6 & 2020 & \( \left(\frac{\left(\left(\left(66 \cdot 66\right) - \left(6 - \left(\frac{\left({6}^{6}\right)}{6}\right)\right)\right) - 6\right)}{6}\right) \) & 10 & 1.284s \\\hline
        6 & 2980 & \( \left(\left({((6 + 6) / 6)}^{6}\right) + \left({(6 + (6 - 66))}^{((6 + 6) / 6)}\right)\right) \) & 11 & 2.073s \\\hline
        7 & 2030 & \( \left(\left(7 \cdot \left(7 - \left(7 \cdot \left(7 - \left(7 \cdot 7\right)\right)\right)\right)\right) - 77\right) \) & 8 & 0.041s \\\hline
        7 & 2020 & \( \left(\left(\frac{77}{7}\right) - \left(7 \cdot \left(7 + \left(7 \cdot \left(7 - \left(7 \cdot 7\right)\right)\right)\right)\right)\right) \) & 9 & 0.239s \\\hline
        7 & 2080 & \( \left(\frac{\left(7 + \left(77 \cdot \left(\left(\left(7 + 7\right) \cdot \left(7 + 7\right)\right) - 7\right)\right)\right)}{7}\right) \) & 9 & 0.372s \\\hline
        7 & 2980 & \( \left(\left(\left(\left(\frac{77}{7}\right) - 7\right) \cdot 777\right) - \left({((7 + 7) / 7)}^{7}\right)\right) \) & 11 & 2.234s \\\hline
        8 & 2080 & \( \left(\left(\left(\frac{8}{8}\right) + \left(8 \cdot 8\right)\right) \cdot \left(8 + \left(8 + \left(8 + 8\right)\right)\right)\right) \) & 8 & 0.033s \\\hline
        8 & 2980 & \( \left(\left(\frac{8}{8}\right) + \left(\frac{\left(8 + \left(\frac{\left({8}^{8}\right)}{\left(8 \cdot 8\right)}\right)\right)}{88}\right)\right) \) & 9 & 0.098s \\\hline
        8 & 2020 & \( \left(\frac{\left(8 + \left(8 \cdot \left(\left(8 \cdot \left(8 \cdot 8\right)\right) - 8\right)\right)\right)}{\left(\frac{\left(8 + 8\right)}{8}\right)}\right) \) & 9 & 0.228s \\\hline
        8 & 2030 & \( \left(\left(\frac{\left(8 - 88\right)}{8}\right) - \left(8 - \left(8 \cdot \left(\left(8 + 8\right) \cdot \left(8 + 8\right)\right)\right)\right)\right) \) & 10 & 0.390s \\\hline
        9 & 2030 & \( \left(\left({((9 + 9) / 9)}^{(99 / 9)}\right) - \left(9 + 9\right)\right) \) & 8 & 0.012s \\\hline
        9 & 2080 & \( \left(\left(9 + \left(9 + \left(9 - \left(\frac{9}{9}\right)\right)\right)\right) \cdot \left(\left(9 \cdot 9\right) - \left(\frac{9}{9}\right)\right)\right) \) & 9 & 0.051s \\\hline
        9 & 2020 & \( \left(\left(\left(\frac{99}{9}\right) + 999\right) \cdot \left(\frac{\left(9 + 9\right)}{9}\right)\right) \) & 9 & 0.053s \\\hline
        9 & 2980 & \( \left(\left(\frac{9}{9}\right) + \left(\left(\left(9 + \left(9 \cdot \left(9 + 9\right)\right)\right) \cdot \left(9 + 9\right)\right) - 99\right)\right) \) & 10 & 0.259s \\\hline
\end{longtable}
\end{center}

\section{Code}

TBD

\section{Anhang}

\subsection{Rechnung zu Theorem \ref{theorem:tn_of_phi}}

%\textcolor{red}{Hier braucht es noch einen Anknüpfungspunkt. Greife mal noch die Ausgangsgleichung  wieder auf, etwa so:}
Der Beweis von Theorem \ref{theorem:tn_of_phi} führt auf folgende Abschätzung
    \[t_n \leq C_n \cdot 5^{n-1} < \frac{4^n}{(n+1)\sqrt{\pi n}} 5^{n-1} =  \frac{20^n}{5(n+1)\sqrt{\pi n}}\]

Nun kann man um die Anzahl der zu betrachtender Terme \(\measure{n}\) statt \(n\) einsetzen, um die Anzahl aller Terme zu bestimmen, die genauso viele Ziffern wie die optimale Repräsentation von \(n\) haben.
Unter Verwendung der Abschätzung \(\measure{n} \leq \log_d(n) \cdot (d+4) + 2\) aus Corollary \ref{corollary:phi_bound} ergeben sich folgende Umformungen:

\begin{align*}
    t_{\measure{\frac{a}{b}}}
    &< \frac{20^{\log_d(n)\cdot(d+4)+2}}{5\Big(\big(\log_d(n) \cdot (d+4)+2\big)+1\Big) \cdot \sqrt{\pi \cdot \log_d(n) \cdot (d+4) + 2}} \\
    &= \frac{(20^{\log_d(n)})^{d+4}\cdot20^2}{5\Big(\big(\log_d(n) \cdot (d+4)+2\big)+1\Big) \cdot \sqrt{\pi \cdot \log_d(n) \cdot (d + 4) + 2}} \\
    &= 80\cdot\frac{(20^{\log_d(n)})^{d+4}}{\big(\log_d(n) \cdot (d+4)+3\big) \cdot\sqrt{\pi \cdot \log_d(n)\cdot(d+4)+2}} \\
    &\leq 80\cdot\frac{(20^{\log_d(n)})^{d+4}}{\log_d(n) \cdot d \cdot \sqrt{\pi \cdot \log_d(n) \cdot d}} \\
    &\leq 80\cdot\frac{(20^{\frac{\log_{20}(n)}{\log_{20}(d)}})^{d+4}}{\log_d(n) \cdot d \cdot \sqrt{\log_d(n) \cdot d}} \\
    &\leq 80\cdot\frac{(n^{\frac{1}{\log_{20}(d)}})^{d+4}}{\big(\log_d(n) \cdot d\big)^{\frac{3}{2}}} \\
    &\leq 80 \cdot n^{\frac{d+4}{\log_{20}(d)}} \cdot \big(\log_d(n) \cdot d\big)^{-\frac{3}{2}} \\
    &\in \mathcal{O}(n^{\frac{d+4}{\log_{20}(d)}} \cdot \big(\log_d(n) \cdot d\big)^{-\frac{3}{2}}) \\
\end{align*}

\end{document}