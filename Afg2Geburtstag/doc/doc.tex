\documentclass{article}

\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=2.2cm,footskip=0.5cm]{geometry}

\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ntheorem}

\usepackage{lmodern}
%\usepackage{csquotes}

\usepackage{tikz}
\usetikzlibrary{chains}
\usetikzlibrary{matrix,positioning,calc}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{breqn}

\usepackage{longtable}

\usepackage{cite}

\usepackage{fancyhdr, lastpage}

\pagestyle{fancy}

\newcommand{\Fpage}{\thepage{}/\pageref{LastPage}}
\newcommand{\Ftitle}{Aufgabe 2: Geburtstag}
\newcommand{\Fauthor}{Nikolas Kilian | Teilnahme ID: 48313}

\lhead{\Fauthor}
\rhead{\Ftitle}
\chead{}
\lfoot{}
\rfoot{}
\cfoot{\Fpage}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\normalfont}
\theoremseparator{.\,—}
\theoremsymbol{}
\newtheorem{proof-wo}{Beweis}
\theoremsymbol{\ensuremath{\color{lightgray}\blacksquare}}
\newtheorem{proof}{Beweis}

%
% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

\usepackage{url}

%\usepackage{courier}
%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{turqoisetypes}{rgb}{0.01,0.60,0.3}
\definecolor{background}{rgb}{0.95,0.95,0.95}
%\definecolor{background}{rgb}{.97,.97,.97}

\newcommand{\codesize}{\small}

\lstdefinelanguage{CSharp}{ % Better C# highlighting
language=[Sharp]C,
frame=lrbt,
%language=general,
backgroundcolor=\color{background},
captionpos=b,
numbers=left,
numberstyle=\tiny,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, get, set, from, select, package, deref},
%
emph=[0]{T,U,V,TToken},
emphstyle=[0]{\color{types}},
%
emph=[1]{Parser,LexemeString,Lexeme,ParserSuccess,ParserError,IParserResult,NotSupportedException,Token,Predicate,EqualityComparer,List,TempleLang,Intermediate,Binder,Bound,CodeGenerator,NASM,Transformer,Abstractions},
emphstyle=[1]{\color{turqoisetypes}},
%
otherkeywords={=>,<,>},
emph=[2]{=>,<,>},
emphstyle=[2]{\bfseries},
%
emph=[3]{ParserResult},
emph=[3]{\color{turqoisetypes}\bfseries},
%
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\codesize\ttfamily,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
}
\lstMakeShortInline[
  language=CSharp,
  columns=fixed,]~

\lstnewenvironment{lstcs}[1][]
    {\lstset{
        language=CSharp,
        breaklines=true, 
        columns=fullflexible,
        caption={#1}
    }}
{}

\newcommand{\sidenote}[1]{&&|\ \text{#1}.}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand{\nldelims}[1]{\right.#1\left.}
\newcommand{\mnl}{\nldelims{\newline}}

\delimitershortfall=-1pt

\usepackage{hyperref}
\usepackage{cleveref}

\setlength{\parskip}{.8em} 
\setlength{\parindent}{0pt}

\begin{document}

\title{\Ftitle}
\author{\Fauthor}

\maketitle

\tableofcontents

\section{Lösungsidee}

Die Kernidee des Algorithmus besteht darin, alle Terme zu ermitteln, die durch \(n\)-fache Verwendung der gegebenen Ziffer und deren Verknüpfung mit sich selbst (wie in der Aufgabenstellung beschrieben) optimal ihren Wert darstellen.
Dies wird induktiv gelöst, wobei für die Errechnung der optimalen Terme mit Größe \(n\) alle kleineren Terme vorausgesetzt werden.
Zuerst werden alle infrage kommenden Terme mit Größe \(n\) gebildet. Hierzu werden alle Terme der Größe \(i\) mit allen Termen der Größe \(n-i\) unter Verwendung aller binärer Operationen gekreuzt.
Daraufhin werden alle Terme entfernt, deren Wert schon mit kleineren oder gleich großen Termen dargestellt wurde.
Um mit diesem Verfahren nun die Aufgabe zu lösen, ermittelt man solange größere Terme, bis der gesuchte Wert optimal von einem Term dargestellt wird.
Diese Vorangehensweise erlaubt es auch, mit der gleichen Ziffer Repräsentationen für mehrere Zahlen auf einmal zu finden, ohne dass sich die Laufzeit addiert.
Hierfür werden einfach größere und größere Terme ermittelt, bis alle Zahlen eine optimale Repräsentation erhalten haben.
Die Laufzeit, um mehrere Zahlen zu repräsentieren entspricht hierbei einfach der längsten Laufzeit, bei dem jede Zahl individuell durch den Algorithmus läuft.

Auf ersten Blick scheint dieser Algorithmus eine exponentielle Komplexität zu besitzen, tatsächlich ist dem aber gar nicht so.
Im Folgenden wird die Komplexität dieses Verfahrens genauer betrachtet.

\newcommand{\fad}{\forall d, B:\ }
\newcommand{\measure}[1]{\Phi_{d}^{B}(#1)}

\subsection{Größenmaß-Funktion}

Zur Berechnung der Komplexität wird die Größenmaß-Funktion \(\Phi_{d}^{B} : \mathbb{Q} \to \mathbb{N}\) betrachtet, die die Anzahl an Instanzen der Ziffer \(d\) errechnet, die für die optimale Repräsentation beliebiger rationaler Zahlen benötigt werden. Dabei ist eine Konkatenierung bezüglich der Basis \(B\) möglich. Beispielsweise wird die Zahl \(11\) aus zwei mal der Ziffer \(1\)  zur Basis \(B=10\) generiert. Für die Größenmaß-Funktion gilt insbesondere \(\fad\measure{d} = 1\).

\begin{lemma}[Größenmaß für nicht-negative ganze Zahlen]\label{lemma:measure_linear_nonnegative}
    Für jede nicht-negative ganze Zahl \(n\) gilt:

    \[\measure{n} \leq n + 2\]
\end{lemma}
\begin{proof}
    \subsubsection*{Fall 1: \(n > 0\)}
    
    \(n > 0\) lässt sich als \(n\)-mal wiederholte Summierung von \(d\) darstellen:
    \[n = \frac{d+d+\ldots+d}{d} \implies \measure{n} \leq n + 1 < n + 2\]

    \subsubsection*{Fall 2: \(n = 0\)}
        
    \(n = 0\) lässt sich immer mit genau zwei Ziffern darstellen:
    \[n = d - d \implies \measure{n} \leq 2 = n + 2\]
\end{proof}
\begin{corollary}[Größenmaß für ganze Zahlen]\label{lemma:measure_linear}
    Für jede ganze Zahl \(n\) gilt:

    \[\fad \measure{n} \leq |n| + 3\]
\end{corollary}

\begin{proof}
    \subsubsection*{Fall 1: \(n \geq 0\)}

    Laut Lemma \ref{lemma:measure_linear_nonnegative} gilt:
    \[\measure{n} \leq n + 2 = |n| + 2 < |n| + 3\]

    \subsubsection*{Fall 2: \(n < 0\)}
        
    \(n < 0\) lässt sich als Differenz aus \(0 = d-d\) und \(|n| > 0\) darstellen:
    \[n = d - d - \frac{d+d+\ldots+d}{d} \implies \measure{n} \leq |n| + 3\]
    oder alternativ unter Verwendung von unärer Negation:
    \[n = -\frac{d+d+\ldots+d}{d} \implies \measure{n} \leq |n| + 1 < |n| + 3\]
\end{proof}

\begin{lemma}[Größenmaß für binäre Operationen]\label{lemma:phi_binary}
    Für jeden binären Operator \(\circ : \mathbb{Q} \times \mathbb{Q} \to \mathbb{Q}\) gilt für alle \(a\in\mathbb{Q},\ b\in\mathbb{Q}\):

    \[\measure{a \circ b} \leq \measure{a} + \measure{b}\]

    Die Anwendung der Größenmaß-Funktion auf binäre Operationen lässt sich also immer durch Addition der Größenmaße der Operanden abschätzen.
\end{lemma}
\begin{proof}
    Die rationalen Zahlen \(a\) und \(b\) lassen sich mit \(\measure{a}\) bzw. \(\measure{b}\) Ziffern ausdrücken, also lässt sich \(a \circ b\) durch Anwendung der Operation \(\circ\) auf die Terme für \(a\) und \(b\) mit \(\measure{a} + \measure{b}\) oder weniger Ziffern ausdrücken.
\end{proof}

\begin{corollary}[Größenmaß für rationale Zahlen]\label{corollary:phi_rational}
    Für jede rationale Zahl \(\frac{a}{b}\in\mathbb{Q},\ a\in\mathbb{Z},\ b\in\mathbb{Z}^+\) gilt:

    \[\measure{\frac{a}{b}} \leq \measure{a} + \measure{b}\]
\end{corollary}
\begin{proof}
    \(\frac{a}{b}\) ist das Ergebnis der Anwendung des binären Divisions-Operators auf \(a\) und \(b\), somit lässt es sich laut Lemma \ref{lemma:phi_binary} mit \(\measure{a} + \measure{b}\) oder weniger Ziffern ausdrücken.
\end{proof}

\begin{theorem}[Genauere obere Grenze des Größenmaßes für positive ganze Zahlen]\label{theorem:accurate_bound}
    Für jede positive ganze Zahl \(n\) gilt:
    
        \[\measure{n} \leq \log_d(n) \cdot (d+4)\]
\end{theorem}
\begin{proof}
    Jede positive ganze Zahl lässt sich im Horner-Schema darstellen.
    Betrachte man die natürliche Zahl \(n\) in Basis \(d\).

        \begin{equation}\label{eqn:horner_schema}
            n = a_1 + d (a_2 + d (\ldots d a_k)),\ a_i\in\mathbb{N},\ 0 \leq a_i < d
        \end{equation}

    Hierbei ist es anzumerken, dass keine Basis 1 existiert und dies somit für \(d=1\) nicht anwendbar ist.
    Im folgenden wird zuerst der generelle Fall betrachtet.
    Aus Gleichung \ref{eqn:horner_schema} lässt sich ablesen:

    \begin{align*}
        \measure{n} 
        &\leq \measure{a_1 + d (a_2 + d (\ldots d a_k))} \sidenote{\ref{lemma:phi_binary}} \\
        &\leq \measure{a_1} + \measure{d} + \measure{a_2} + \measure{d} + \ldots + \measure{d} + \measure{a_k} \\
        &= (k-1)\cdot\measure{d} + \sum_{i=1}^k \measure{a_i} \numberthis\label{eqn:semi_accurate_bound}
    \end{align*}
    
    Da \(0 \leq a_i < d\) gilt, folgt mit Lemma \ref{lemma:measure_linear_nonnegative} für jedes \(a_i\): \(\measure{a_i} \leq d + 2\).
    Zusammen mit \(\measure{d} = 1\) folgt aus Abschätzung \ref{eqn:semi_accurate_bound}:
    
    \begin{align*}
        \measure{n} 
        &\leq (k-1) \cdot 1 + \sum_{i=1}^k (d+2) \\
        &\leq (k-1) + k \cdot (d+2) \\
        &\leq k + k \cdot (d+2) = k \cdot (d+3) \\
    \end{align*}
Bei der Repräsentation mit dem Horner-Schema gilt \(k = \lfloor \log_d(n) \rfloor\), somit folgt:
        \[\measure{n} \leq k \cdot (d+3) = \lfloor \log_d(n) \rfloor \cdot (d+3) \leq \log_d(n) \cdot (d+3)\]

Das Problem der non-existenten Basis für den Spezialfall \(d = 1\) kann durch den folgenden Trick umgangen werden:
Anstelle von \(d = 1\) wird die  Basis \(2 = 1 + 1 = d + d\) betrachtet.   
In Abschätzung \ref{eqn:semi_accurate_bound} muss dann nur \(\measure{d}\) durch \(\measure{d + d} = 2\cdot\measure{d}\) ersetzt werden:
    \[\measure{n} \leq (k-1) \cdot 2 \cdot \measure{d} + \sum_{i=1}^k \measure{a_i}\]
und es folgt analog zu oben:
    \begin{align*}
        \measure{n} 
        &\leq k \cdot (d+4) \\
        &\leq \log_d(n) \cdot (d+4) \\
    \end{align*}

Somit gilt sowohl im generellen Fall als auch im Spezialfall die Abschätzung \(\measure{n} \leq \log_d(n) \cdot (d+4)\).
\end{proof}

\begin{corollary}[Genauere obere Grenze des Größenmaßes für ganze Zahlen]\label{corollary:phi_bound}
    Für jede ganze Zahl \(n\) gilt:
    
        \[\measure{n} \leq \log_d(n) \cdot (d+4) + 2\]
\end{corollary}
\begin{proof}
    Analog zum Beweis von Lemma \ref{lemma:measure_linear}.
\end{proof}

\subsection{Anzahl an Termen}

Die Anzahl an Termen mit \(n\) Ziffern sei definiert als \(t_n\).
Bei Größe \(0\) gibt es beispielsweise \(t_0 = 0\) Terme, bei \(1\) gibt es \(t_1 = 1\) Terme und bei \(2\) gibt es \(t_2 = 6\) Terme (\(d; dd; d+d; d-d; d \cdot d; d \div d\)).

\begin{theorem}[Abschätzung für \(t_n\)]\label{theorem:tn_bound}
    Die Anzahl an Termen lässt sich wie folgt nach oben abschätzen

        \[t_n \leq C_n \cdot 5^{n-1}\,,\]
     wobei \(C_n\) die Catalan Zahlen bezeichnet.
\end{theorem}
\begin{proof}
    Terme von Größe \(n\) können als volle Binärbäume mit \(n\) Blättern aufgefasst werden, wobei jedes Blatt eine Ziffer oder eine Wiederholung der Ziffer darstellt und jeder Knoten eine binäre Operation zwischen seinen zwei Kindern darstellt.
    Am Beispiel für \(6 = (1+1)\cdot(1+(1+1))\):
    \begin{center}
        \begin{tikzpicture}[level/.style={sibling distance = 4cm,  level distance = 0.8cm}] 
        \node [circle,draw] {$\cdot$}
            child{ node  [circle,draw] {$+$}
                child{ node  [circle,draw] {$1$}} 
                child{ node  [circle,draw] {$1$}} 
            }
            child{ node  [circle,draw] {$+$} 
                child{ node  [circle,draw] {$1$}} 
                child{ node  [circle,draw] {$+$}
                    child{ node  [circle,draw] {$1$}} 
                    child{ node  [circle,draw] {$1$}} 
                } 
            }
        ; 
        \end{tikzpicture}
    \end{center}
    Hierbei werden auch invalide Terme mit Division durch Null wie \(1 \div (1-1)\) mit betrachtet.
    Jedoch sind alle validen Terme wie oben repräsentierbar, so dass die Anzahl solcher Binärbäume größer als die Anzahl valider Terme ist und somit geeignet für eine obere Abschätzung.
    Nachfolgend werden zunächst nur Terme ohne Konkatenierung von Ziffern betrachtet.

    Betrachte man nun zuerst die Anzahl solcher Binärbäume.
    Die Anzahl an vollen Binärbäumen mit \(n\) Blättern wird durch die Catalan Zahlen \(C_n\) beschrieben.
    Die Catalan Zahlen beschreiben jedoch nur die Anzahl an Binärbäumen, nicht die Anzahl an Binärbäumen mit Operatoren in den Knoten.
    In einem vollen Binärbaum mit \(n\) Blättern gibt es \(n-1\) Knoten bzw. \(n-1\) Operatoren.
    Bei \(4\) Operatoren heißt das, dass die Anzahl an Kombinationen von Operatoren \(4^{n-1}\) beträgt.
    Folglich ist die Anzahl an Binärbäumen mit Operatoren in den Knoten das Produkt dieser beiden Zahlen: \(C_n \cdot 4^{n-1}\).

    Um nun auch die Konkatenierung von Ziffern zu berücksichtigen, kann man sich einen Konkatenierungs-Operator vorstellen:
    \[l \circ r = B \cdot l + r \,,\quad\quad\text{bspw.: } 1\circ1 = B + 1 = 10 + 1 = 11\]
    
    Dieser würde natürlich auch ``unerlaubte'' Konkatenierungen erlauben, beispielsweise für \(B=10\):
     \[(4+4+4) \circ (4\cdot4) = 12 \circ 16 = 12B + 16 = 120 + 16 = 136\]

    Jedoch werden so alle validen Konkatenierungen und mehr abgebildet, weshalb er für eine Abschätzung nach oben geeignet ist.
    Nun lässt sich die vorherige Herangehensweise analog durchführen, jedoch diesmal mit \(5\) Operatoren.
    Somit ist die Anzahl an Termen der Größe \(n\) kleiner gleich \(C_n \cdot 5^{n-1}\).
\end{proof}

\begin{theorem}[Anzahl zu betrachtender Terme]\label{theorem:tn_of_phi}
    Aus Corollary \ref{corollary:phi_bound}, \ref{corollary:phi_rational} und Theorem \ref{theorem:tn_bound} folgt, dass für jede rationale Zahl \(n\in\mathbb{Q}\) gilt:

        \[\sum_{i=0}^{\measure{n}} t_i \in \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}\]

    Was bedeutet, dass die Anzahl an Termen, die zur Darstellung von \(n\) die Ziffer minimal verwenden, polynomial zu \(n\) abschätzbar ist.
\end{theorem}
\begin{proof}
    Laut Theorem \ref{theorem:tn_bound} gilt:

        \[t_n \leq C_n \cdot 5^{n-1}\]

    Für die Catalan Zahlen gilt folgende obere Abschätzung\footnote{Siehe Seite 212: \url{https://www.sciencedirect.com/science/article/pii/S0195669886800245}}:

        \[C_n < \frac{4^n}{(n+1)\sqrt{\pi n}}\]

    Somit folgt:

        \[t_n \leq C_n \cdot 5^{n-1} < \frac{4^n}{(n+1)\sqrt{\pi n}} 5^{n-1} = \frac{4^n \cdot 5^n}{5(n+1)\sqrt{\pi n}} = \frac{20^n}{5(n+1)\sqrt{\pi n}}\]

    Nun kann man um die Anzahl der für \(n\) zu betrachtender Terme \(\measure{n}\) statt \(n\) einsetzen, um die Anzahl aller Terme zu bestimmen, die genauso viele Ziffern wie die optimale Repräsentation von \(n\) haben.
    Mit Corollary \ref{corollary:phi_bound} gilt nach einer ganzen Reihe von Umformungen (siehe Anhang):
    
    \begin{equation}
        t_{\measure{n}}
        = \mathcal{O}\Big(n^{\frac{d+4}{\log_{20}(d)}} \cdot \underbrace{\big(\log_d(n) \cdot d\big)^{-\frac{3}{2}}}_{\text{streng monoton fallend}}\Big) \\
        = \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}
    \end{equation}

    Da die Ziffer \(d\) dabei immer konstant ist, ist auch \(\alpha\) konstant.
    Somit ist \(t_{\measure{n}}\) nach oben polynomial abschätzbar.
    \pagebreak
    
    Da der Algorithmus induktiv arbeitet, werden zur Bestimmung der Terme von Größe \(n\) die Terme von Größe \(n-1\) benötigt.
    Daher entspricht die Anzahl der Terme, die für eine optimale Repräsentation von \(n\) zu betrachten sind, der Summe der Anzahl aller Terme mit genauso vielen oder weniger Ziffern wie die optimale Repräsentation \(n\), also \(\sum_{i=0}^{\measure{n}} t_i\). Da die Komplexitätsklasse einer Summe von Elementen der polynomialen Komplexitätsklasse wieder die polynomiale Komplexitätsklasse ist, ist diese Summe somit auch polynomial:

    \[\sum_{i=0}^{\measure{n}} t_i \in \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\frac{d+4}{\log_{20}(d)}\]
\end{proof}

Da immer alle Ziffern (außer 0) verwendet werden, muss diese Komplexität für alle Ziffern addiert werden.
Somit ist die Komplexität eine Summe aus Potenzen, also ebenfalls eine Potenz:

\[t_{\measure{n}} \in \mathcal{O}(n^{\alpha}),\qquad\text{mit }\alpha=\max_{0 < d \leq 9}\frac{d+4}{\log_{20}(d)}\]

Auch wenn quasi purer Brute-Force verwendet wird, so belegen diese Überlegungen dennoch, dass eine polynomiale Komplexität vorliegt.
Da der eigentliche Algorithmus durch die Eliminierung von Duplikaten noch einmal stärker optimiert ist, ist dessen Komplexität natürlich auch polynomial.

\subsection{Exponenten und Fakultäten}

Um den Algorithmus auf Exponenten und Fakultäten zu erweitern, kann zuerst Exponentiation als zusätzlicher binärer Operator wie Addition und Multiplikation hinzugefügt werden.
Dabei bleibt die Komplexität analog zu vorher polynomial, nur zu einem größeren Exponenten.

Für die Hinzunahme von Fakultäten ist dies jedoch nicht so leicht.
Zunächst lässt sich Fakultät relativ leicht in den Algorithmus einbauen, wobei jeder neue optimale Term noch einmal mit einer Fakultät hinten zu der Liste aller optimalen Terme addiert wird.
Das Problem besteht allerdings darin, dass Fakultät eine unäre Operation ist, weshalb sie unabhängig von der Anzahl an Instanzen der Ziffer beliebig oft verwendbar ist; beispielsweise ist \(((((d!)!)!)!)!\) in der Theorie erlaubt.
Betrachtet man jedoch die Werte der Fakultäts-Funktion, so fällt auf, dass dort sehr schnell immens große Werte entstehen; beispielsweise ist \((5!)!=120!\), was eine Zahl mit 199 Ziffern ist.
Dass diese Werte nur sehr selten brauchbar sind, ist relativ offensichtlich.

Zur Umgehung dieses Problems habe ich daher ein Limit eingefügt, das Fakultäten von Zahlen größer \(20\) verbietet, wobei \(20!\) die größte durch signierte 64-Bit Integer darsellbare Fakultät ist.
Somit ist \((4!)!\) gerade noch erlaubt, jedoch \((5!)!\) verboten.
Dies lässt sich auch leicht implementieren, wobei jeder neue Term mit Wert \(x < 80\) den neuen Term \(x!\) rekursiv einfügt.
Dabei muss man jedoch noch darauf achten, dass keine Endlosschleifen auftauchen: \(1 = 1! = \ldots = ((1!)!)!\)

Es lässt sich erkennen, dass hierbei höchstens zwei Fakultäten in Reihe auftreten können.
Das bedeutet, dass für jeden neu gefundenen optimalen Term noch (höchstens) zwei weitere Terme addiert werden.
Dies bedeutet, dass sich die Rechenzeit (höchstens) verdreifacht, und somit immer noch polynomial ist.

Im Hinblick auf Fakultäten ist noch bemerkenswert, dass nun auch die Ziffer \(0\) verwendet werden kann:
\(0! = 1\).
Die Beispiele unten enthalten daher auch Lösungen mit der Ziffer \(0\).

\section{Umsetzung}

Der Algorithmus wurde in C\# 8.0 mit .NET Core 3.1 implementiert.
Es wurde als Library CommandLineParser\footnote{https://github.com/commandlineparser/commandline} verwendet. Diese implementiert Methoden um Unix-Style Konsolenargumente entgegenzunehmen.
Der Code ist in zwei Projekte geteilt;
~Afg2Geburtstag.CLI~ und ~Afg2Geburtstag~.
~Afg2Geburtstag.CLI~ kümmert sich um das Konsolen-Interface und ruft ~Afg2Geburtstag~ auf, was den eigentlichen Algorithmus enthält.
~Afg2Geburtstag~ definiert einige Typen:

\begin{description}
    \item[Rational] definiert rationale Zahlen und Operationen auf diesen.
    \item[ITerm] repräsentiert eine Schnittstelle für beliebige Terme mit einem ~Rational~ Wert. Wird von ~Rational~ implementiert.
    \item[UnaryOperator] repräsentiert einen unären Operator der zur Erstellung einer ~UnaryOperation~ verwendet werden kann.
    \item[UnaryOperation] repräsentiert eine unäre Operation auf einem ~ITerm~ und implementiert selbst ~ITerm~.
    \item[BinaryOperator] repräsentiert einen binären Operator der zur Erstellung einer ~BinaryOperation~ verwendet werden kann.
    \item[BinaryOperation] repräsentiert eine binäre Operation zwischen zwei ~ITerm~s und implementiert selbst ~ITerm~.
    \item[DigitRepresenter] enthält den Kernalgorithmus für eine Ziffer und mehrere Zielzahlen.
\end{description}

~UnaryOperation~ und ~BinaryOperation~ speichern als Optimierung ihren berechneten Wert und Hashcode.
Weiterhin sind die Operanden der beiden Typen ~ITerm~ Instanzen und somit Referenztypen.
Dies bedeutet, dass jede Operation nur einmal gespeichert wird und nicht in anderen Operationen, die sie verwenden, gedoppelt wird.

In ~DigitRepresenter~, worin der Hauptalgorithmus implementiert wird, werden an vielen Stellen Hashsets verwendet, um schnelle Lookups zu erlauben.
Spezifischer, da ~HashSet<T>~ nicht Thread-Safe ist, verwendet der Code ~ConcurrentDictionary<T, byte>~, wobei der ~byte~-Wert ignoriert wird.

Für Informationen zur Verwendung des Programms kann ~Afg2Geburtstag.exe --help~ ausgeführt werden.

\section{Beispiele}

\subsection{Ohne Exponenten und Fakultäten}

Argumente:
~--targets 2020, 2030, 2080, 2980 --digits 1,2,3,4,5,6,7,8,9 --sync --latex~

% Targets: 2020, 2030, 2080, 2980
% Digits: 1, 2, 3, 4, 5, 6, 7, 8, 9
% Base: 10
%
\begin{center}
    \begin{longtable}{ | l | l | p{9.5cm} | l | l | }
    \hline \textbf{Digit} & \textbf{Value} & \textbf{Term} & \textbf{Digit Usages} & \textbf{Time} \\\hline
            1 & 2020 & \( \left(\left(1 + 1\right) \cdot \left(\frac{\left(11111 - 1\right)}{11}\right)\right) \) & 10 & 0.075s \\\hline
            1 & 2030 & \( \left(\left(11 - 1\right) \cdot \left(\left(\left(1 + 1\right) \cdot \left(1 - \left(11 - 111\right)\right)\right) + 1\right)\right) \) & 12 & 0.102s \\\hline
            1 & 2080 & \( \left(\left(11 - 1\right) \cdot \left(\left(11 \cdot \left(\left(\left(1 + 1\right) \cdot \left(11 - 1\right)\right) - 1\right)\right) - 1\right)\right) \) & 12 & 0.105s \\\hline
            1 & 2980 & \( \left(\left(11 - 1\right) \cdot \left(1 - \left(\left(1 - \left(11 - 1\right)\right) \cdot \left(11 \cdot \left(1 + \left(1 + 1\right)\right)\right)\right)\right)\right) \) & 13 & 0.154s \\\hline
            2 & 2020 & \( \left(2 \cdot \left(\left(\left(2 + \left(2 \cdot 22\right)\right) \cdot 22\right) - 2\right)\right) \) & 8 & 0.002s \\\hline
            2 & 2080 & \( \left(\left(2 \cdot \left(2 \cdot \left(22 - 2\right)\right)\right) \cdot \left(2 + \left(2 + 22\right)\right)\right) \) & 9 & 0.005s \\\hline
            2 & 2030 & \( \left(2 + \left(2 \cdot \left(2 + \left(\left(2 + \left(2 \cdot 22\right)\right) \cdot 22\right)\right)\right)\right) \) & 9 & 0.011s \\\hline
            2 & 2980 & \( \left(2 \cdot \left(2 - \left(\left(2 + 22\right) \cdot \left(\left(2 \cdot \left(2 - 22\right)\right) - 22\right)\right)\right)\right) \) & 11 & 0.152s \\\hline
            3 & 2020 & \( \left(\left(\left(3 + 333\right) \cdot \left(3 + 3\right)\right) + \left(3 + \left(\frac{3}{3}\right)\right)\right) \) & 9 & 0.009s \\\hline
            3 & 2030 & \( \left(33 - \left(\left(\frac{3}{3}\right) - \left(333 \cdot \left(3 + 3\right)\right)\right)\right) \) & 9 & 0.015s \\\hline
            3 & 2080 & \( \left(\left(33 \cdot \left(33 + \left(33 - 3\right)\right)\right) + \left(\frac{3}{3}\right)\right) \) & 9 & 0.015s \\\hline
            3 & 2980 & \( \left(\left(\frac{3}{3}\right) + \left(3 \cdot \left(3 + \left(33 \cdot \left(33 - 3\right)\right)\right)\right)\right) \) & 9 & 0.017s \\\hline
            4 & 2080 & \( \left(\left(44 - 4\right) \cdot \left(4 + \left(4 + 44\right)\right)\right) \) & 7 & 0.002s \\\hline
            4 & 2020 & \( \left(\left(44 \cdot \left(\left(\frac{\left(4 + 4\right)}{4}\right) + 44\right)\right) - 4\right) \) & 8 & 0.004s \\\hline
            4 & 2980 & \( \left(4 - \left(\left(4 \cdot 4\right) - \left(\left(4 + \left(4 \cdot \left(4 \cdot 4\right)\right)\right) \cdot 44\right)\right)\right) \) & 9 & 0.018s \\\hline
            4 & 2030 & \( \left(\left(4 \cdot \left(\left(4 \cdot \left(4 \cdot \left(4 \cdot \left(4 + 4\right)\right)\right)\right) - 4\right)\right) - \left(\frac{\left(4 + 4\right)}{4}\right)\right) \) & 10 & 0.182s \\\hline
            5 & 2980 & \( \left(5 + \left(5 - \left(\left(\left(\frac{5}{5}\right) - 55\right) \cdot 55\right)\right)\right) \) & 8 & 0.007s \\\hline
            5 & 2030 & \( \left(\left(5 \cdot \left(5 + \left(5 \cdot \left(\left(5 \cdot 5\right) + 55\right)\right)\right)\right) + 5\right) \) & 8 & 0.007s \\\hline
            5 & 2020 & \( \left(\left(5 \cdot \left(5 + \left(5 \cdot \left(\left(5 \cdot 5\right) + 55\right)\right)\right)\right) - 5\right) \) & 8 & 0.008s \\\hline
            5 & 2080 & \( \left(\left(\left(5 \cdot 5\right) + 55\right) \cdot \left(\left(\frac{5}{5}\right) + \left(5 \cdot 5\right)\right)\right) \) & 8 & 0.008s \\\hline
            6 & 2030 & \( \left(\left(\left(\frac{\left(6 + 6\right)}{6}\right) - \left(66 - 6\right)\right) \cdot \left(\left(\frac{6}{6}\right) - \left(6 \cdot 6\right)\right)\right) \) & 10 & 0.058s \\\hline
            6 & 2020 & \( \left(\left(6 - \left(\frac{6}{6}\right)\right) \cdot \left(\left(\frac{\left(6 + 6\right)}{6}\right) + \left(6 + \left(6 \cdot 66\right)\right)\right)\right) \) & 10 & 0.130s \\\hline
            6 & 2080 & \( \left(\left(66 - \left(\frac{6}{6}\right)\right) \cdot \left(\left(\frac{\left(6 + 6\right)}{6}\right) + \left(\left(6 \cdot 6\right) - 6\right)\right)\right) \) & 10 & 0.171s \\\hline
            6 & 2980 & \( \left(\frac{\left(\left(\left(\left(\left(6 \cdot \left(6 \cdot \left(6 + 6\right)\right)\right) - 6\right) \cdot \left(6 + \left(6 \cdot 6\right)\right)\right) - 6\right) - 6\right)}{6}\right) \) & 11 & 0.328s \\\hline
            7 & 2030 & \( \left(\left(7 \cdot \left(7 + \left(7 \cdot \left(\left(7 \cdot 7\right) - 7\right)\right)\right)\right) - 77\right) \) & 8 & 0.006s \\\hline
            7 & 2020 & \( \left(\left(\frac{77}{7}\right) + \left(7 \cdot \left(\left(7 \cdot \left(\left(7 \cdot 7\right) - 7\right)\right) - 7\right)\right)\right) \) & 9 & 0.014s \\\hline
            7 & 2080 & \( \left(\frac{\left(7 + \left(77 \cdot \left(\left(\left(7 + 7\right) \cdot \left(7 + 7\right)\right) - 7\right)\right)\right)}{7}\right) \) & 9 & 0.036s \\\hline
            7 & 2980 & \( \left(\frac{\left(\left(\left(\left(7 + \left(7 \cdot \left(77 - 7\right)\right)\right) \cdot \left(\left(7 \cdot 7\right) - 7\right)\right) - 7\right) - 7\right)}{7}\right) \) & 11 & 0.322s \\\hline
            8 & 2080 & \( \left(\left(8 + \left(8 + \left(8 + 8\right)\right)\right) \cdot \left(\left(\frac{8}{8}\right) + \left(8 \cdot 8\right)\right)\right) \) & 8 & 0.005s \\\hline
            8 & 2020 & \( \left(\frac{\left(8 \cdot \left(8 - \left(8 \cdot \left(8 - \left(8 \cdot \left(8 \cdot 8\right)\right)\right)\right)\right)\right)}{\left(8 + 8\right)}\right) \) & 9 & 0.036s \\\hline
            8 & 2030 & \( \left(\left(\left(8 + 8\right) \cdot \left(8 \cdot \left(8 + 8\right)\right)\right) - \left(8 - \left(\frac{\left(8 - 88\right)}{8}\right)\right)\right) \) & 10 & 0.132s \\\hline
            8 & 2980 & \( \left(\left(\frac{8}{8}\right) + \left(\frac{\left(8 + \left(\left(8 \cdot \left(8 \cdot \left(8 \cdot 8\right)\right)\right) \cdot \left(8 \cdot 8\right)\right)\right)}{88}\right)\right) \) & 11 & 0.523s \\\hline
            9 & 2020 & \( \left(\left(9 + \left(\frac{99}{9}\right)\right) \cdot \left(\left(\frac{\left(9 + 9\right)}{9}\right) + 99\right)\right) \) & 9 & 0.011s \\\hline
            9 & 2080 & \( \left(\left(\frac{9}{9}\right) + \left(99 \cdot \left(9 + \left(\frac{\left(9 + 99\right)}{9}\right)\right)\right)\right) \) & 9 & 0.012s \\\hline
            9 & 2980 & \( \left(9 + \left(\frac{\left(9 + \left(\left(9 + \left(9 + 9\right)\right) \cdot \left(999 - 9\right)\right)\right)}{9}\right)\right) \) & 10 & 0.059s \\\hline
            9 & 2030 & \( \left(\left(\left(9 \cdot 9\right) - \left(\frac{99}{9}\right)\right) \cdot \left(9 + \left(9 + \left(\frac{99}{9}\right)\right)\right)\right) \) & 10 & 0.130s \\\hline
    \end{longtable}
\end{center}

\subsection{Mit Exponenten und Fakultäten}

Argumente:
~--targets 2020, 2030, 2080, 2980~
~--digits 0,1,2,3,4,5,6,7,8,9~\\
~--exponentiation --factorial --sync --latex~

% % Targets: 2020, 2030, 2080, 2980
% % Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
% % Base: 10
% % Exponentiation Factorial
% \begin{center}
%     \begin{longtable}{ | l | l | p{9.5cm} | l | l | }
%     \hline \textbf{Digit} & \textbf{Value} & \textbf{Term} & \textbf{Digit Usages} & \textbf{Time} \\\hline
%         0 & 2980 & \( \left(\left(\left(0!\right) + \left(\left(0!\right) + \left(\left(0!\right) + \left(0!\right)\right)\right)\right) \mnl\quad\cdot \left(\left(0!\right) + \left(\left((((0!) + (0!)) + ((0!) + (0!)))!\right) \nldelims{\nldelims{\mnl}}\ \ + \left(((((0!) + (0!)) + (0!))!)!\right)\right)\right)\right) \) & 24 & 0.476s \\\hline
%         0 & 2080 & \( \left(\left({((0!) + (0!))}^{(((((0!) + (0!)) + (0!))!) - (0!))}\right) \mnl\quad\cdot \left(\left(0!\right) + \left({((0!) + (0!))}^{((((0!) + (0!)) + (0!))!)}\right)\right)\right) \) & 24 & 0.487s \\\hline
%         0 & 2020 & \( \left(\left(\left(0!\right) + \left(0!\right)\right) \cdot \left(\left(0!\right) + \left(\left(0!\right) \nldelims{\nldelims{\mnl}}\ \ - \left(\frac{\left(((0!) + ((((0!) + (0!)) + (0!))!))!\right)}{\left(\left(0!\right) - \left((((0!) + (0!)) + (0!))!\right)\right)}\right)\right)\right)\right) \) & 24 & 0.490s \\\hline
%         0 & 2030 & \( \left(\left(0!\right) + \left(\left(\left(\left(0!\right) + \left(\left(0!\right) + \left(0!\right)\right)\right) \cdot \left(((0!) + ((0!)+ ((((0!) \nldelims{\nldelims{\nldelims{\mnl}}}\ \ + (0!)) + ((0!) + (0!)))!)))^{((0!) + (0!))}\right)\right) + \left(0!\right)\right)\right) \) & 26 & 0.838s \\\hline
%         1 & 2080 & \( \left(\left(\left(1 + \left(1 + 1\right)\right) \cdot 11\right) + \left(\left({(1 + 1)}^{11}\right) - 1\right)\right) \) & 10 & 0.037s \\\hline
%         1 & 2030 & \( \left(\left(\left(\left({(1 + 1)}^{11}\right) - 1\right) - \left(((1 + 1) + 1)!\right)\right) - 11\right) \) & 10 & 0.037s \\\hline
%         1 & 2020 & \( \left(\frac{\left(\left(11111 - 1\right) \cdot \left(1 + 1\right)\right)}{11}\right) \) & 10 & 0.047s \\\hline
%         1 & 2980 & \( \left(\left(\left(((((1 + 1) + 1)!) + 1)!\right) - \left(\left({(1 + 1)}^{11}\right) + 11\right)\right) - 1\right) \) & 11 & 0.180s \\\hline
%         2 & 2080 & \( \left(\left({(2 * 22)}^{2}\right) + \left({(((2 * 2)!) / 2)}^{2}\right)\right) \) & 8 & 0.019s \\\hline
%         2 & 2030 & \( \left(\left(\left({2}^{(22 / 2)}\right) - 22\right) + \left(2 + 2\right)\right) \) & 8 & 0.020s \\\hline
%         2 & 2020 & \( \left(\left(\left({2}^{(22 / 2)}\right) - \left(2 + 2\right)\right) - \left((2 * 2)!\right)\right) \) & 8 & 0.039s \\\hline
%         2 & 2980 & \( \left(\left({(2 * ((2 * 2)!))}^{2}\right) + \left({(2 + ((2 * 2)!))}^{2}\right)\right) \) & 8 & 0.043s \\\hline
%         3 & 2080 & \( \left(\left(3 \cdot \left(\left(((3 * 3) - 3)!\right) - \left({3}^{3}\right)\right)\right) + \left(\frac{3}{3}\right)\right) \) & 8 & 0.077s \\\hline
%         3 & 2030 & \( \left(\left(33 - \left(\frac{3}{3}\right)\right) + \left(333 \cdot \left(3 + 3\right)\right)\right) \) & 9 & 0.188s \\\hline
%         3 & 2020 & \( \left(\left(3 + \left(\left(3 + 3\right) \cdot \left(3 + 333\right)\right)\right) + \left(\frac{3}{3}\right)\right) \) & 9 & 0.326s \\\hline
%         3 & 2980 & \( \left(\left(\frac{3}{3}\right) - \left(3 \cdot \left(\left(\left(3 - 33\right) \cdot 33\right) - 3\right)\right)\right) \) & 9 & 0.386s \\\hline
%         4 & 2080 & \( \left(\left(4 + 4\right) \cdot \left(4 + \left({4}^{4}\right)\right)\right) \) & 5 & 0.001s \\\hline
%         4 & 2020 & \( \left(4 + \left(\left(\left({4}^{4}\right) - 4\right) \cdot \left(4 + 4\right)\right)\right) \) & 6 & 0.002s \\\hline
%         4 & 2980 & \( \left(\left(\left(\left({4}^{4}\right) - 4\right) \cdot \left(4 + \left(4 + 4\right)\right)\right) - 44\right) \) & 8 & 0.052s \\\hline
%         4 & 2030 & \( \left(\left({4}^{4}\right) - \left(\left(\frac{\left(4 + 4\right)}{4}\right) - \left(4 \cdot 444\right)\right)\right) \) & 9 & 0.174s \\\hline
%         5 & 2980 & \( \left(\left(5 - \left(5 \cdot \left(5 + \left(5 \cdot 5\right)\right)\right)\right) + \left({5}^{5}\right)\right) \) & 7 & 0.005s \\\hline
%         5 & 2080 & \( \left(\left(5 + \left(5 \cdot \left(5 \cdot 5\right)\right)\right) \cdot \left(5 + \left(\frac{55}{5}\right)\right)\right) \) & 8 & 0.035s \\\hline
%         5 & 2030 & \( \left(\left(5 + \left({5}^{5}\right)\right) - \left(\left(\left(5 \cdot 5\right) - 5\right) \cdot 55\right)\right) \) & 8 & 0.036s \\\hline
%         5 & 2020 & \( \left(\left(5 \cdot \left(5 + \left(5 \cdot \left(\left(5 \cdot 5\right) + 55\right)\right)\right)\right) - 5\right) \) & 8 & 0.062s \\\hline
%         6 & 2030 & \( \left(\left(\left(\frac{6}{6}\right) - \left(6 \cdot 6\right)\right) \cdot \left(6 - \left({((6 + 6) / 6)}^{6}\right)\right)\right) \) & 9 & 0.232s \\\hline
%         6 & 2080 & \( \left(\left(\left(\frac{6}{6}\right) - 66\right) \cdot \left(\left(6 - \left(6 \cdot 6\right)\right) - \left(\frac{\left(6 + 6\right)}{6}\right)\right)\right) \) & 10 & 0.721s \\\hline
%         6 & 2020 & \( \left(\frac{\left(\left(\left(66 \cdot 66\right) - \left(6 - \left(\frac{\left({6}^{6}\right)}{6}\right)\right)\right) - 6\right)}{6}\right) \) & 10 & 1.284s \\\hline
%         6 & 2980 & \( \left(\left({((6 + 6) / 6)}^{6}\right) + \left({(6 + (6 - 66))}^{((6 + 6) / 6)}\right)\right) \) & 11 & 2.073s \\\hline
%         7 & 2030 & \( \left(\left(7 \cdot \left(7 - \left(7 \cdot \left(7 - \left(7 \cdot 7\right)\right)\right)\right)\right) - 77\right) \) & 8 & 0.041s \\\hline
%         7 & 2020 & \( \left(\left(\frac{77}{7}\right) - \left(7 \cdot \left(7 + \left(7 \cdot \left(7 - \left(7 \cdot 7\right)\right)\right)\right)\right)\right) \) & 9 & 0.239s \\\hline
%         7 & 2080 & \( \left(\frac{\left(7 + \left(77 \cdot \left(\left(\left(7 + 7\right) \cdot \left(7 + 7\right)\right) - 7\right)\right)\right)}{7}\right) \) & 9 & 0.372s \\\hline
%         7 & 2980 & \( \left(\left(\left(\left(\frac{77}{7}\right) - 7\right) \cdot 777\right) - \left({((7 + 7) / 7)}^{7}\right)\right) \) & 11 & 2.234s \\\hline
%         8 & 2080 & \( \left(\left(\left(\frac{8}{8}\right) + \left(8 \cdot 8\right)\right) \cdot \left(8 + \left(8 + \left(8 + 8\right)\right)\right)\right) \) & 8 & 0.033s \\\hline
%         8 & 2980 & \( \left(\left(\frac{8}{8}\right) + \left(\frac{\left(8 + \left(\frac{\left({8}^{8}\right)}{\left(8 \cdot 8\right)}\right)\right)}{88}\right)\right) \) & 9 & 0.098s \\\hline
%         8 & 2020 & \( \left(\frac{\left(8 + \left(8 \cdot \left(\left(8 \cdot \left(8 \cdot 8\right)\right) - 8\right)\right)\right)}{\left(\frac{\left(8 + 8\right)}{8}\right)}\right) \) & 9 & 0.228s \\\hline
%         8 & 2030 & \( \left(\left(\frac{\left(8 - 88\right)}{8}\right) - \left(8 - \left(8 \cdot \left(\left(8 + 8\right) \cdot \left(8 + 8\right)\right)\right)\right)\right) \) & 10 & 0.390s \\\hline
%         9 & 2030 & \( \left(\left({((9 + 9) / 9)}^{(99 / 9)}\right) - \left(9 + 9\right)\right) \) & 8 & 0.012s \\\hline
%         9 & 2080 & \( \left(\left(9 + \left(9 + \left(9 - \left(\frac{9}{9}\right)\right)\right)\right) \cdot \left(\left(9 \cdot 9\right) - \left(\frac{9}{9}\right)\right)\right) \) & 9 & 0.051s \\\hline
%         9 & 2020 & \( \left(\left(\left(\frac{99}{9}\right) + 999\right) \cdot \left(\frac{\left(9 + 9\right)}{9}\right)\right) \) & 9 & 0.053s \\\hline
%         9 & 2980 & \( \left(\left(\frac{9}{9}\right) + \left(\left(\left(9 + \left(9 \cdot \left(9 + 9\right)\right)\right) \cdot \left(9 + 9\right)\right) - 99\right)\right) \) & 10 & 0.259s \\\hline
% \end{longtable}
% \end{center}
% Targets: 2020, 2030, 2080, 2980
% Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
% Base: 10
% Exponentiation Factorial
\begin{center}
    \begin{longtable}{ | l | l | p{9.5cm} | l | l | }
    \hline \textbf{Digit} & \textbf{Value} & \textbf{Term} & \textbf{Digit Usages} & \textbf{Time} \\\hline
            0 & 2980 & \( \left(\left(\left(0!\right) + \left(\left(0!\right) + \left(\left(0!\right) + \left(0!\right)\right)\right)\right) \mnl\quad\cdot \left(\left(\left(0!\right) + \left(\left(\left(\left(0!\right) + \left(0!\right)\right) + \left(\left(0!\right) + \left(0!\right)\right)\right)!\right)\right) \nldelims{\mnl}\ \ + \left(\left(\left(\left(\left(0!\right) + \left(0!\right)\right) + \left(0!\right)\right)!\right)!\right)\right)\right) \) & 24 & 0.292s \\\hline
            0 & 2080 & \( \left(\left(\left(0!\right) + \left({\left(\left(0!\right) + \left(0!\right)\right)}^{\left(\left(\left(\left(0!\right) + \left(0!\right)\right) + \left(0!\right)\right)!\right)}\right)\right) \mnl\quad\cdot \left({\left(\left(0!\right) + \left(0!\right)\right)}^{\left(\left(\left(\left(\left(0!\right) + \left(0!\right)\right) + \left(0!\right)\right)!\right) - \left(0!\right)\right)}\right)\right) \) & 24 & 0.293s \\\hline
            0 & 2020 & \( \left(\left(\left(0!\right) + \left(0!\right)\right) \cdot \left(\left(\left(0!\right) + \left(0!\right)\right) \nldelims{\mnl}\ \ - \left(\frac{\left(\left(\left(0!\right) + \left(\left(\left(\left(0!\right) + \left(0!\right)\right) + \left(0!\right)\right)!\right)\right)!\right)}{\left(\left(0!\right) - \left(\left(\left(\left(0!\right) + \left(0!\right)\right) + \left(0!\right)\right)!\right)\right)}\right)\right)\right) \) & 24 & 0.341s \\\hline
            0 & 2030 & \( \left(\left(\left(0!\right) + \left(0!\right)\right) + \left(\left(\left(0!\right) + \left(\left(0!\right) + \left(0!\right)\right)\right) \cdot \left(\left(\left(0!\right) + \left(\left(0!\right) \nldelims{\nldelims{\nldelims{\nldelims{\mnl}}}}\ \ + \left(\left(\left(\left(0!\right) + \left(0!\right)\right) + \left(\left(0!\right) + \left(0!\right)\right)\right)!\right)\right)\right)^{\left(\left(0!\right) + \left(0!\right)\right)}\right)\right)\right) \) & 26 & 0.964s \\\hline
            1 & 2080 & \( \left(\left(\left(1 + \left(1 + 1\right)\right) \cdot 11\right) - \left(1 - \left({\left(1 + 1\right)}^{11}\right)\right)\right) \) & 10 & 0.060s \\\hline
            1 & 2030 & \( \left(\left(\left(\left({\left(1 + 1\right)}^{11}\right) - \left(\left(\left(1 + 1\right) + 1\right)!\right)\right) - 1\right) - 11\right) \) & 10 & 0.083s \\\hline
            1 & 2020 & \( \left(\frac{\left(\left(11111 - 1\right) \cdot \left(1 + 1\right)\right)}{11}\right) \) & 10 & 0.127s \\\hline
            1 & 2980 & \( \left(\left(\left(\left(\left(\left(1 + 1\right) + 1\right)!\right) + 1\right)!\right) \mnl\ \ - \left(\left(1 + \left({\left(1 + 1\right)}^{11}\right)\right) + 11\right)\right) \) & 11 & 0.405s \\\hline
            2 & 2020 & \( \left(\left(\left({2}^{\left(\frac{22}{2}\right)}\right) - \left(\left(2 \cdot 2\right)!\right)\right) - \left(2 + 2\right)\right) \) & 8 & 0.029s \\\hline
            2 & 2030 & \( \left(\left(\left({2}^{\left(\frac{22}{2}\right)}\right) - 22\right) + \left(2 + 2\right)\right) \) & 8 & 0.031s \\\hline
            2 & 2080 & \( \left(\left({2}^{\left(\frac{22}{2}\right)}\right) + \left(2 \cdot \left({2}^{\left(2 + 2\right)}\right)\right)\right) \) & 8 & 0.035s \\\hline
            2 & 2980 & \( \left(2 \cdot \left(2 + \left(2 \cdot \left(\left(\left(2 \cdot 2\right)!\right) + \left(\left(\left(2 + 2\right) + 2\right)!\right)\right)\right)\right)\right) \) & 8 & 0.103s \\\hline
            3 & 2080 & \( \left(\left(\frac{3}{3}\right) - \left(3 \cdot \left(\left({3}^{3}\right) - \left(\left(\left(3 \cdot 3\right) - 3\right)!\right)\right)\right)\right) \) & 8 & 0.105s \\\hline
            3 & 2030 & \( \left(\left(33 + \left(333 \cdot \left(3 + 3\right)\right)\right) - \left(\frac{3}{3}\right)\right) \) & 9 & 0.300s \\\hline
            3 & 2980 & \( \left(\frac{\left(3 + \left(\left({33}^{3}\right) - \left({\left(3 + \left({3}^{3}\right)\right)}^{3}\right)\right)\right)}{3}\right) \) & 9 & 0.448s \\\hline
            3 & 2020 & \( \left(\left(\frac{3}{3}\right) + \left(3 + \left(\left(3 + 333\right) \cdot \left(3 + 3\right)\right)\right)\right) \) & 9 & 0.831s \\\hline
            4 & 2080 & \( \left(\left(4 + 4\right) \cdot \left(4 + \left({4}^{4}\right)\right)\right) \) & 5 & 0.001s \\\hline
            4 & 2020 & \( \left(4 + \left(\left(\left({4}^{4}\right) - 4\right) \cdot \left(4 + 4\right)\right)\right) \) & 6 & 0.002s \\\hline
            4 & 2980 & \( \left(4 \cdot \left(\left({\left(4 + \left(\frac{4}{4}\right)\right)}^{4}\right) + \left(\left(\left(\frac{4}{4}\right) + 4\right)!\right)\right)\right) \) & 8 & 0.147s \\\hline
            4 & 2030 & \( \left(\left({4}^{4}\right) - \left(\left(\frac{\left(4 + 4\right)}{4}\right) - \left(4 \cdot 444\right)\right)\right) \) & 9 & 0.272s \\\hline
            5 & 2980 & \( \left(5 + \left(5 \cdot \left(\left(5 \cdot \left(\left(5 \cdot \left(\frac{5}{5}\right)\right)!\right)\right) - 5\right)\right)\right) \) & 7 & 0.004s \\\hline
            5 & 2020 & \( \left(\left({5}^{5}\right) + \left(\left(\left(5 - \left(5 \cdot 5\right)\right) \cdot 55\right) - 5\right)\right) \) & 8 & 0.025s \\\hline
            5 & 2030 & \( \left(\left({5}^{5}\right) + \left(5 - \left(55 \cdot \left(\left(5 \cdot 5\right) - 5\right)\right)\right)\right) \) & 8 & 0.054s \\\hline
            5 & 2080 & \( \left(\left(5 + \left(\frac{55}{5}\right)\right) \cdot \left(5 + \left(5 \cdot \left(5 \cdot 5\right)\right)\right)\right) \) & 8 & 0.055s \\\hline
            6 & 2030 & \( \left(\left({\left(\frac{\left(6 + 6\right)}{6}\right)}^{\left(\frac{66}{6}\right)}\right) - \left(6 + \left(6 + 6\right)\right)\right) \) & 9 & 0.454s \\\hline
            6 & 2020 & \( \left(\frac{\left(\left(\left(\frac{\left({6}^{6}\right)}{6}\right) - \left(6 + 6\right)\right) + \left(66 \cdot 66\right)\right)}{6}\right) \) & 10 & 2.340s \\\hline
            6 & 2080 & \( \left(\frac{\left(\left(\left(\frac{6}{6}\right) + \left(6 + 6\right)\right)!\right)}{\left(\left({\left(6 + 6\right)}^{6}\right) + \left(\frac{\left({6}^{6}\right)}{6}\right)\right)}\right) \) & 10 & 2.928s \\\hline
            6 & 2980 & \( \left(6 - \left(\frac{\left(\frac{\left(\left(\left(6 - \left(\left(\left(\frac{6}{6}\right) + 6\right)!\right)\right) \cdot \left(6 + 6\right)\right) - \left({6}^{6}\right)\right)}{6}\right)}{6}\right)\right) \) & 11 & 7.633s \\\hline
            7 & 2030 & \( \left(\left(7 \cdot \left(7 - \left(7 \cdot \left(7 - \left(7 \cdot 7\right)\right)\right)\right)\right) - 77\right) \) & 8 & 0.101s \\\hline
            7 & 2020 & \( \left(\left(\frac{77}{7}\right) - \left(7 \cdot \left(7 + \left(7 \cdot \left(7 - \left(7 \cdot 7\right)\right)\right)\right)\right)\right) \) & 9 & 0.660s \\\hline
            7 & 2080 & \( \left(\frac{\left(7 + \left(77 \cdot \left(\left(\left(7 + 7\right) \cdot \left(7 + 7\right)\right) - 7\right)\right)\right)}{7}\right) \) & 9 & 0.948s \\\hline
            7 & 2980 & \( \left(\left(\left(77 + \left(\left(\frac{7}{7}\right) - 7\right)\right) \cdot \left(\left(7 \cdot 7\right) - 7\right)\right) - \left(\frac{\left(7 + 7\right)}{7}\right)\right) \) & 11 & 10.411s \\\hline
            8 & 2080 & \( \left(\left(\left(8 + \left(8 + 8\right)\right) \cdot \left(88 - \left(\frac{8}{8}\right)\right)\right) - 8\right) \) & 8 & 0.046s \\\hline
            8 & 2980 & \( \left(\left(\frac{8}{8}\right) + \left(\frac{\left(8 + \left(\frac{\left(\frac{\left({8}^{8}\right)}{8}\right)}{8}\right)\right)}{88}\right)\right) \) & 9 & 0.293s \\\hline
            8 & 2020 & \( \left(\frac{\left(8 \cdot \left(8 - \left(8 \cdot \left(8 - \left(8 \cdot \left(8 \cdot 8\right)\right)\right)\right)\right)\right)}{\left(8 + 8\right)}\right) \) & 9 & 0.887s \\\hline
            8 & 2030 & \( \left(\left(\left(\frac{\left(\frac{\left(\left(8 \cdot \left(\frac{8}{8}\right)\right)!\right)}{8}\right)}{8}\right) - 8\right) + \left(\left(8 + 8\right) \cdot 88\right)\right) \) & 10 & 1.325s \\\hline
            9 & 2030 & \( \left(\left({\left(\frac{\left(9 + 9\right)}{9}\right)}^{\left(\frac{99}{9}\right)}\right) - \left(9 + 9\right)\right) \) & 8 & 0.076s \\\hline
            9 & 2080 & \( \left(\left(\frac{9}{9}\right) + \left(\left(9 + \left(\frac{\left(9 + 99\right)}{9}\right)\right) \cdot 99\right)\right) \) & 9 & 0.171s \\\hline
            9 & 2020 & \( \left(\frac{\left(\left(\left(\frac{99}{9}\right) + 999\right) \cdot \left(9 + 9\right)\right)}{9}\right) \) & 9 & 0.186s \\\hline
            9 & 2980 & \( \left(\left(\frac{9}{9}\right) + \left(\left(9 \cdot \left(9 + \left(\left(9 + 9\right) \cdot \left(9 + 9\right)\right)\right)\right) - \left(9 + 9\right)\right)\right) \) & 10 & 0.854s \\\hline
    \end{longtable}
\end{center}

\section{Code}

\begin{lstcs}[]
/// <summary>
/// Represents an arbitrary mathematical teerm.
/// </summary>
public interface ITerm
{
    /// <summary>
    /// The value of the term.
    /// </summary>
    Rational Value { get; }

    /// <summary>
    /// Returns a string that represents the current object.
    /// </summary>
    /// <returns>A string that represents the current object.</returns>
    string ToString();

    /// <summary>
    /// Returns a string that represents the current object as latex code.
    /// </summary>
    /// <returns>A string that represents the current object as latex code.</returns>
    string ToLaTeX();
}
\end{lstcs}

\begin{lstcs}[]
using RationalSet = System.Collections.Concurrent.ConcurrentDictionary<Rational, byte>;
using TermSet = System.Collections.Concurrent.ConcurrentDictionary<ITerm, byte>;

/// <summary>
/// Contains the main algorithm.
/// </summary>
public class DigitRepresenter
{
    /// <summary>
    /// All binary operators available.
    /// </summary>
    public List<BinaryOperator> BinaryOperators { get; }

    /// <summary>
    /// Contains a unary operator. <c>null</c> if no unary operator is to be used.
    /// Multiple unary operators are no supported.
    /// </summary>
    public UnaryOperator? UnaryOperator { get; }

    /// <summary>
    /// All calculated terms, where the set at index i contains all the terms which use the digit i times.
    /// </summary>
    public List<TermSet> TermsOfSize { get; }

    /// <summary>
    /// Contains all values of all terms.
    /// </summary>
    public RationalSet AllValues { get; }

    public long Digit { get; }
    public long Base { get; }

    /// <summary>
    /// All targets to find representations for, along with their optimal representation, if one was found.
    /// </summary>
    public ConcurrentDictionary<Rational, ITerm?> Targets { get; }

    /// <summary>
    /// The number of targets for which no optimal representation has been found yet.
    /// </summary>
    public int UnfoundTargets { get; private set; }

    /// <summary>
    /// An action to execute once an optimal representation for any given target was found.
    /// </summary>
    public Action<ITerm, int> OnFound { get; }

    public DigitRepresenter(
        List<BinaryOperator> binaryOperators,
        UnaryOperator? unaryOperator,
        ConcurrentDictionary<Rational, ITerm?> hitTargets,
        Action<ITerm, int> onFound,
        long digit,
        long @base = 10)
    {
        TermsOfSize = new List<TermSet>() { new TermSet() };
        AllValues = new RationalSet();
        BinaryOperators = binaryOperators;
        UnaryOperator = unaryOperator;
        Digit = digit;
        Base = @base;

        Targets = hitTargets;
        UnfoundTargets = hitTargets.Count;
        OnFound = onFound;
    }

    /// <summary>
    /// Calculates all terms of size.
    /// </summary>
    /// <param name="size">The size of the terms to calculate.</param>
    public void CalculateAllOfSize(int size)
    {
        if (TermsOfSize.Count < size) CalculateAllOfSize(size - 1);
        else if (TermsOfSize.Count > size) return;
        var currentTerms = new TermSet();

        // The digit concatenated with itself <size> times
        var repeatedDigit = Digit;
        for (int i = 1; i < size; i++) repeatedDigit = (repeatedDigit * Base) + Digit;
        RegisterTerm(currentTerms, new Rational(repeatedDigit), size);

        // Execute all different ways of combining the smaller terms to terms of size <size> in parallel
        Parallel.For(1, size, i =>
        {
            var allLhs = TermsOfSize[i];
            var allRhs = TermsOfSize[size - i];

            foreach (var lhs in allLhs)
            {
                foreach (var rhs in allRhs)
                {
                    foreach (var @operator in BinaryOperators)
                    {
                        var term = BinaryOperation.Create(@operator, lhs.Key, rhs.Key);

                        RegisterTerm(currentTerms, term, size);

                        if (UnfoundTargets == 0) return;
                    }
                }
            }
        });

        TermsOfSize.Add(currentTerms);
    }

    /// <summary>
    /// Adds <paramref name="term"/> and repeated applications of <see cref="UnaryOperator"/> upon it
    /// to <paramref name="termSet"/>if the terms are optimal representations of their values.
    /// </summary>
    /// <param name="termSet">The set of terms to add the terms to.</param>
    /// <param name="term">The term.</param>
    /// <param name="digitCount">The amount of times the digit is used in <paramref name="term"/>.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void RegisterTerm(TermSet termSet, ITerm? term, int digitCount)
    {
        if (term == null) return;
        if (AddTermIfNew(termSet, term, digitCount)) return;

        if (UnaryOperator == null) return;

        // Apply the unary operator repeatedly until either
        //  - The value stops changing
        //  - The unary operator cannot be applied anymore (values too big, trying to compute (-1)! etc.)
        do
        {
            var newTerm = UnaryOperation.Create(UnaryOperator, term);
            if (newTerm == null || newTerm.Value == term.Value) break;
            term = newTerm;
        }
        while (AddTermIfNew(termSet, term, digitCount));
    }

    /// <summary>
    /// Adds <paramref name="term"/> to <paramref name="termSet"/> if the term are optimal representations of
    /// their values and their values are not yet represented by any other term.
    /// If the term is the value of a target <see cref="OnFound"/> is called
    /// and the term is stored as its optimal representation.
    /// </summary>
    /// <param name="termSet">The set of terms to add the term to.</param>
    /// <param name="term">The term.</param>
    /// <param name="digitCount">The amount of times the digit is used in <paramref name="term"/>.</param>
    /// <returns>Whether the value was added.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool AddTermIfNew(TermSet termSet, ITerm? term, int digitCount)
    {
        // Don't add null or exisitng values
        if (term == null || AllValues.ContainsKey(term.Value))
        {
            return false;
        }

        // Check if the terms value is a target
        if (Targets.TryGetValue(term.Value, out var otherTerm) && otherTerm == null)
        {
            Targets[term.Value] = term;
            UnfoundTargets--;
            OnFound(term, digitCount);
        }

        // Add the term as key with value 0, as the value is ignored
        AllValues.TryAdd(term.Value, 0);
        termSet.TryAdd(term, 0);

        return true;
    }
}
\end{lstcs}

\section{Anhang}

\subsection{Rechnung zu Theorem \ref{theorem:tn_of_phi}}

%\textcolor{red}{Hier braucht es noch einen Anknüpfungspunkt. Greife mal noch die Ausgangsgleichung  wieder auf, etwa so:}
Der Beweis von Theorem \ref{theorem:tn_of_phi} führt auf folgende Abschätzung
    \[t_n \leq C_n \cdot 5^{n-1} < \frac{4^n}{(n+1)\sqrt{\pi n}} 5^{n-1} =  \frac{20^n}{5(n+1)\sqrt{\pi n}}\]

Nun kann man um die Anzahl der zu betrachtender Terme \(\measure{n}\) statt \(n\) einsetzen, um die Anzahl aller Terme zu bestimmen, die genauso viele Ziffern wie die optimale Repräsentation von \(n\) haben.
Unter Verwendung der Abschätzung \(\measure{n} \leq \log_d(n) \cdot (d+4) + 2\) aus Corollary \ref{corollary:phi_bound} ergeben sich folgende Umformungen:

\begin{align*}
    t_{\measure{\frac{a}{b}}}
    &< \frac{20^{\log_d(n)\cdot(d+4)+2}}{5\Big(\big(\log_d(n) \cdot (d+4)+2\big)+1\Big) \cdot \sqrt{\pi \cdot \log_d(n) \cdot (d+4) + 2}} \\
    &= \frac{(20^{\log_d(n)})^{d+4}\cdot20^2}{5\Big(\big(\log_d(n) \cdot (d+4)+2\big)+1\Big) \cdot \sqrt{\pi \cdot \log_d(n) \cdot (d + 4) + 2}} \\
    &= 80\cdot\frac{(20^{\log_d(n)})^{d+4}}{\big(\log_d(n) \cdot (d+4)+3\big) \cdot\sqrt{\pi \cdot \log_d(n)\cdot(d+4)+2}} \\
    &\leq 80\cdot\frac{(20^{\log_d(n)})^{d+4}}{\log_d(n) \cdot d \cdot \sqrt{\pi \cdot \log_d(n) \cdot d}} \\
    &\leq 80\cdot\frac{(20^{\frac{\log_{20}(n)}{\log_{20}(d)}})^{d+4}}{\log_d(n) \cdot d \cdot \sqrt{\log_d(n) \cdot d}} \\
    &\leq 80\cdot\frac{(n^{\frac{1}{\log_{20}(d)}})^{d+4}}{\big(\log_d(n) \cdot d\big)^{\frac{3}{2}}} \\
    &\leq 80 \cdot n^{\frac{d+4}{\log_{20}(d)}} \cdot \big(\log_d(n) \cdot d\big)^{-\frac{3}{2}} \\
    &\in \mathcal{O}(n^{\frac{d+4}{\log_{20}(d)}} \cdot \big(\log_d(n) \cdot d\big)^{-\frac{3}{2}}) \\
\end{align*}

\end{document}