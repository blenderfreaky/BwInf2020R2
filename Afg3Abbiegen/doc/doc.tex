\documentclass{article}

\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=2.2cm,footskip=0.5cm]{geometry}

\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ntheorem}
\usepackage{xcolor}

\usepackage{lmodern}
%\usepackage{csquotes}

\usepackage{tikz}
\usetikzlibrary{chains}
\usetikzlibrary{matrix,positioning,calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary {positioning}

\usepackage{cite}

\usepackage{fancyhdr, lastpage}

\pagestyle{fancy}

\newcommand{\Fpage}{\thepage{}/\pageref{LastPage}}
\newcommand{\Ftitle}{Aufgabe 2 Geburtstag}
\newcommand{\Fauthor}{Nikolas Kilian}

\lhead{\Fauthor}
\rhead{\Ftitle}
\chead{}
\lfoot{}
\rfoot{}
\cfoot{\Fpage}

\setlength{\parskip}{.8em} 
\setlength{\parindent}{0pt}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}
%\usepackage{pxfonts}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

%
% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

\usepackage{url}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\normalfont}
\theoremseparator{.\,—}
\theoremsymbol{}
\newtheorem{proof-wo}{Beweis}
\theoremsymbol{\ensuremath{\color{lightgray}\blacksquare}}
\newtheorem{proof}{Beweis}

\begin{document}
    
\section{Lösungsidee}

Die Lösungsidee besteht darin, den Dijkstra Algorithmus derart umzugestalten, dass er den Weg mit der geringsten Zahl an Abbiegungen statt der geringsten Länge sucht.

Zuerst wird der kürzeste Weg berechnet, woraufhin dessen Länge und die Anzahl der darinenthaltenen Abbiegungen bestimmt wird. Daraufhin beginnt die Ermittlung des endgültigem Wegs.

Grundlegend verläuft dieser Prozess wie der normale Dijkstra Algorithmus, jedoch mit ein paar kleinen Unterschieden:
Der erste Unterschied besteht darin, dass der Algorithmus alle Wege mit einer Länge größer der Länge des kürzesten Wegs plus die erlaubte Extrastrecke (also +15\% oder +30\%) eliminiert.
Der Hauptunterschied ist, dass Dijkstra hierbei nicht nach Länge, sondern nach Anzahl an Abbiegungen optimiert.

\subsection{Modifizierter Dijkstra im Detail}

Um Dijkstra im Hinblick auf die minimale Anzahl an Abbiegungen umzudefinieren, könnte die zugrunde liegende Kostenfunktion anstelle der Länge des Graphen die Existenz von Abbiegungen betrachten, entweder mit einer '1' für eine Abbiegung oder einer '0' für eine Gerade. 
Dabei fällt auf, dass zur Berechnung der Kosten für eine Kante auch die im Weg vorangehende Kante betrachtet werden muss.
Dies bedeutet aber, dass Dijkstra nicht in seiner ursprünglichen Form verwendet werden kann. Es könnte ansonsten der Fall auftreten, dass Knoten des Graphen von einem anderen Weg aus erneut besucht würden, was die Kosten der Kanten verändern würde, die mit dem Knoten verbunden sind.

\begin {center}
\begin {tikzpicture}[-latex, auto, node distance =4 cm and 5cm, on grid,semithick,
state/.style={ circle, draw, minimum width =1 cm}]
\node[state] (A1)                 {};
\node[state] (2) [right = of    A1] {};
\node[state] (A3) [right = of 2] {};

\node[state] (B1) [below = of A1] {};
\node[state] (B3) [right = of 2] {};

\path (A1) edge node[below =0.15 cm] {$0$} (2);
\path (2) edge node[below =0.15 cm] {$0$} (A3);

\path (B1) edge node[below =0.15 cm] {$0$} (2);
\path (2) edge node[below =0.15 cm] {$0$} (B3);
\end{tikzpicture}
\end{center}

Um dieses Problem zu umgehen, wird der Graph verändert: Zwar werden
Kreuzungen innerhalb des Graphen immer noch als Knoten dargestellt, jedoch gibt es für jede Kreuzung mehrere Knoten, nämlich jeweils einen für jede geradlinige Straße, die in der Kreuzung vorhanden ist.
Alle Knoten einer Kreuzung sind dabei verbunden durch Kanten mit Kosten von 1.

\textcolor{red}{Das verstehe ich leider auch nicht genau, wo sind denn die mehreren Knoten für eine Kreuzung in dem Bild?}

%TODO: Remove arrows
\begin {center}
\begin {tikzpicture}[-latex, auto, node distance =4 cm and 5cm, on grid,semithick,
state/.style={ circle, draw, minimum width =1 cm}]
\node[state] (A1)                 {};
\node[state] (A2) [right = of A1] {};
\node[state] (A3) [right = of A2] {};

\node[state] (B1) [below = of A1] {};
\node[state] (B2) [right = of B1] {};
\node[state] (B3) [right = of B2] {};

\path (A1) edge node[below =0.15 cm] {$0$} (A2);
\path (A2) edge node[below =0.15 cm] {$0$} (A3);

\path (B1) edge node[below =0.15 cm] {$0$} (B2);
\path (B2) edge node[below =0.15 cm] {$0$} (B3);

\path (A2) edge node[right =0.15 cm] {$1$} (B2);
\end{tikzpicture}
\end{center}

Der 

\end{document}